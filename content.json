[{"title":"如何向hexo博客中插入图片","slug":null,"date":"2023-06-29T13:41:13.000Z","updated":null,"comments":null,"path":"uncategorized/2023-06-29/如何向hexo博客中插入图片.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"本文演示如何使用hexo + typora 如何方便插入图片到GitHub博客中 安装博客主目录执行： 12npm install hexo-renderer-markednpm install hexo-image-link 配置_config.yml1post_asset_folder: true typora配置文件 -&gt; 偏好设置 -&gt; 图像： 验证hexo new test此时在source&#x2F;_posts目录会生成一个test目录和test.md文件，然后拷贝图片到test.md中，图片会自动复制到test目录,复制图片粘贴到Typora中叫文章名的文章后，图片引用路径会变成相对路径将图片前面的文章名目录删除掉，替换即可最后发布即可","raw":null,"content":null,"categories":null,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damotiansheng.github.io/tags/hexo/"},{"name":"typora","slug":"typora","permalink":"http://damotiansheng.github.io/tags/typora/"}]},{"title":"redis集群代理twemproxy源码阅读总结","slug":null,"date":"2023-06-21T07:29:31.000Z","updated":null,"comments":null,"path":"twemproxy/2023-06-21/redis集群代理twemproxy源码阅读总结.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"阅读twemproxy的总结文章,方便后续复看和复用其中的技术 代码全景代码规模不大只有1w多行，而且功能划分的比较清晰，包括： 事件处理： event&#x2F;nc_epoll.c、event&#x2F;nc_event.h、event&#x2F;nc_evport.c、event&#x2F;nc_kqueue.c 各种Hash函数： hashkit&#x2F;nc_crc16.c、hashkit&#x2F;nc_crc32.c、hashkit&#x2F;nc_fnv.c、hashkit &#x2F;nc_hashkit.h、hashkit&#x2F;nc_hsieh.c、hashkit&#x2F;nc_jenkins.c、hashkit &#x2F;nc_ketama.c、hashkit&#x2F;nc_md5.c、hashkit&#x2F;nc_modula.c、hashkit&#x2F;nc_murmur.c、 -hashkit&#x2F;nc_one_at_a_time.c、hashkit&#x2F;nc_random.c 协议： proto&#x2F;nc_memcache.c、proto&#x2F;nc_proto.h、proto&#x2F;nc_redis.c 自定义的数据类型： nc_array.c、nc_array.h、nc_string.c、nc_string.h 网络通信相关： nc_connection.c、nc_connection.h、nc_client.c、nc_client.h、nc_proxy.c、nc_proxy.h 信号处理： nc_signal.c、nc_signal.h 关键数据结构和算法： nc_rbtree.h、nc_rbtree.c、nc_queue.h、nc_request.c、nc_response.c、nc_mbuf.c、 nc_mbuf.h、- nc_message.c、nc_message.h、nc_server.c、nc_server.h 统计、日志和工具： nc_stats.c、nc_stats.h、nc_log.c、nc_log.h、nc_util.c、nc_util.h 配置文件： nc_conf.c、nc_conf.h 主程序： nc.c、nc_core.c、nc_core.h 一些技术实现 采用epoll + 回调的单线程工作模式，单线程epoll监听，每个事件触发则调用相应的回调函数 可监听多个地址，客户端向这些地址发起连接请求，每个地址将请求转发到后端的server池 实现上是通过创建多个socket，监听多个地址，然后加入epoll监听中，单线程epoll_wait监听请求 三种连接：proxy：监听客户端连接、client：处理客户端数据连接、server：后端server的连接，每种连接都会保存起读写回调函数，每个连接会用一个conn数据结构表示，相关的读写回调函数会记录在此，每新建一个连接时会加入到时间管理器的监听事件中（每个连接有一个fd），并将该conn赋值给epoll_event.data.ptr，以便事件触发时得到该conn，从而调用到相应的回调函数，proxy连接的回调函数是在conn_get_proxy函数中初始化的，client和server连接的回调函数是在conn_get函数中初始化的 事件驱动消息流转：多个in&#x2F;out队列，消息根据当前的处理流程会进入到某个队列中，从后端server得到回包后，会将请求的msg和回包的msg关联起来，然后client连接找到相应的回包并发送给客户端，整个流程是事件驱动的 总共2个线程，主线程和stats线程 stats线程实现原理：一个简单的http服务，即请求一个http的url，返回stats数据，实现原理：创建一个新的stats线程，epoll_create创建新的事件管理器，创建监听fd，加入epoll的监听事件中并设置回调函数，有请求来了调用相应的回调函数进行处理，默认30秒触发一次 超时处理：请求后端server如果配置了超时，则会进行超时处理，具体是发送给后端请求后，如果规定时间没返回，会超时关闭客户端连接，实现上是通过红黑树实现，key是超时的时间，value是连接，每次epoll从红黑树得到最小的时间（最左节点）赋值给ctx-&gt;timeout，然后传入epoll_wait的第四个参数，epoll_wait(ep, event, nevent, timeout)，到达规定时间后epoll_wait会返回，实现对超时事件的处理 在redis中，超时事件的实现是通过一个双向链表，每次遍历得到最早超时事件，然后传入epoll_wait的参数中的 事件驱动实现：提供了统一的上层接口，底层封装了epoll、kqueue、evport实现，跟redis事件驱动实现类似 实现了一些核心数据结构和算法：红黑树、一致性hash算法（用来选择后端server，将请求路由到后端某个server去）、变长字符串、变长数组、队列（实现来源于https://github.com/freebsd/freebsd-src/blob/master/sys/sys/queue.h）、使用libyaml库解析这个yaml格式的配置文件 守护进程实现：nc_daemonize函数 连接缓冲池技术&amp;连接的LRU管理：每个后端server维护一个s_conn_q连接队列，建立的连接放到该队列中，每次需要建立该server的连接就判断是否超过最大连接数（pool-&gt;server_connections，默认为1），没有则建立新的连接插入队列，超过则从队头取连接conn并插入到队尾（即LRU算法），然后返回这个连接，完成对连接的复用，代码见conn_get函数 空闲连接队列free_connq，三种连接：proxy，client，server在释放连接时会将连接放到空闲连接队列中，需要建立连接时从该空闲连接队列取连接，而不是重新分配内存，相当于一个空闲连接池，三种连接复用该空闲连接池，简单理解就是一个连接数据结构的缓存池，不用每次重新分配 消息结构的缓存池技术：读取消息需要先分配msg结构，优先从空闲msg队列free_msgq中获取，相当于一个msg缓冲池 一次请求的处理流程三种连接 proxy connection， 用来监听用户建立连接的请求，建立连接成功后会对应产生一个客户端连接 client connection，由建连成功后产生，用户读写数据都是通过 client connection 解析请求后，根据 key 和哈希规则选择一个 server 进行转发 server connection，转发用户请求到缓存资源并接收和解析响应数据转回 client connection，client connection 将响应返回到用户 三个队列上图的 client connection 之所以没有 imsgq 是因为请求解析完可以直接进入 server 的 imsgq 用户通过 proxy connection 建立连接，产生一个 client connection client connection 开始读取用户的请求数据，并将完整的请求根据 key 和设置的哈希规则选择 server, 然后将这个请求存放到 server 的 imsgq 接着 server connection 发送 imsgq 请求到远程资源，发送完成之后(写 tcp buffer) 就会将 msg 从 imsgq 迁移到 omsgq，响应回来之后从 omsgq 队列里面找到这个对应的 msg 以及 client connection 最后将响应内容放到 client connection 的 omsgq，由 client connection 将数据发送回客户端。 连接的回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394proxy连接：conn-&gt;recv = proxy_recv;conn-&gt;recv_next = NULL;conn-&gt;recv_done = NULL;conn-&gt;send = NULL;conn-&gt;send_next = NULL;conn-&gt;send_done = NULL;conn-&gt;close = proxy_close;conn-&gt;active = NULL;conn-&gt;ref = proxy_ref;conn-&gt;unref = proxy_unref;client连接：conn-&gt;recv = msg_recv;conn-&gt;recv_next = req_recv_next;conn-&gt;recv_done = req_recv_done;conn-&gt;send = msg_send;conn-&gt;send_next = rsp_send_next;conn-&gt;send_done = rsp_send_done;conn-&gt;close = client_close;conn-&gt;active = client_active;conn-&gt;ref = client_ref;conn-&gt;unref = client_unref;conn-&gt;enqueue_inq = NULL;conn-&gt;dequeue_inq = NULL;conn-&gt;enqueue_outq = req_client_enqueue_omsgq;conn-&gt;dequeue_outq = req_client_dequeue_omsgq;server连接：conn-&gt;recv = msg_recv;conn-&gt;recv_next = rsp_recv_next;conn-&gt;recv_done = rsp_recv_done;conn-&gt;send = msg_send;conn-&gt;send_next = req_send_next;conn-&gt;send_done = req_send_done;conn-&gt;close = server_close;conn-&gt;active = server_active;conn-&gt;ref = server_ref;conn-&gt;unref = server_unref;conn-&gt;enqueue_inq = req_server_enqueue_imsgq;conn-&gt;dequeue_inq = req_server_dequeue_imsgq;conn-&gt;enqueue_outq = req_server_enqueue_omsgq;conn-&gt;dequeue_outq = req_server_dequeue_omsgq;* Client+ Proxy Server+ * (nutcracker) * . * msg_recv &#123;read event&#125; . msg_recv &#123;read event&#125; * + . + * | . | * \\ . / * req_recv_next . rsp_recv_next * + . + * | . | Rsp * req_recv_done . rsp_recv_done &lt;=== * + . + * | . | * Req \\ . / * ===&gt; req_filter* . *rsp_filter * + . + * | . | * \\ . / * req_forward-// (a) . (c) \\\\-rsp_forward * . * . * msg_send &#123;write event&#125; . msg_send &#123;write event&#125; * + . + * | . | * Rsp&#x27; \\ . / Req&#x27; * &lt;=== rsp_send_next . req_send_next ===&gt; * + . + * | . | * \\ . / * rsp_send_done-// (d) . (b) //-req_send_done * * * (a) -&gt; (b) -&gt; (c) -&gt; (d) is the normal flow of transaction consisting * of a single request response, where (a) and (b) handle request from * client, while (c) and (d) handle the corresponding response from the * server. 请求处理流转前文说过三种连接，都注册到了事件管理器中，并保存了读写回调函数（proxy连接只有读函数，因为只需要accept接收client连接请求），当有相应的事件触发，就会调用相应的回调函数进行处理，一个请求的处理流程为：client发起连接请求 -&gt; client发起命令请求 -&gt; server连接可写 -&gt; server连接可读 -&gt; client连接可写，下面按这些事件依次介绍，可以看到msg使用到了三个队列（颜色标识）： client发起连接请求 client发起命令请求 server连接可写事件触发 server返回回包触发可读事件 client连接可写事件触发 参考文章 文章地址 说明 https://www.cnblogs.com/foxmailed/p/3623817.html 源码解析，请求消息的流转过程和处理过程 https://idning.github.io/twemproxy-src.html 内容很全，各个介绍，源码分析 https://hulkdev.com/posts-meitu-opensource-twemproxy/ 美图多进程 twemproxy 开源实现：https://github.com/bitleak/twemproxy https://juejin.cn/post/6844903981429293063 twemproxy源码分析，核心流程介绍 https://github.com/joeylichang/joeylichang.github.io/blob/master/src/redis/twemproxy.md Twemproxy介绍 https://xie.infoq.cn/article/2ee961483c66a146709e7e861 结合nginx架构优化twemproxy https://xie.infoq.cn/article/2ee961483c66a146709e7e861 二次开发，Nginx master-worker机制引入到twemproxy https://github.com/twitter/twemproxy/commit/0060f4a6467903ad66d7fe5721653c327ef9f675#diff-1345cb5f953e43b06356881448bf3cecd997604cfd2240f10e994113892ea88a twemproxy添加ping命令修改","raw":null,"content":null,"categories":null,"tags":[{"name":"twemproxy","slug":"twemproxy","permalink":"http://damotiansheng.github.io/tags/twemproxy/"},{"name":"redis","slug":"redis","permalink":"http://damotiansheng.github.io/tags/redis/"},{"name":"源码总结系列","slug":"源码总结系列","permalink":"http://damotiansheng.github.io/tags/%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97/"}]},{"title":"c与c++相互调用","slug":null,"date":"2017-05-12T05:58:26.000Z","updated":null,"comments":null,"path":"c-c/2017-05-12/c与c++相互调用.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"目的实现C++中调用C函数以及C调用C++函数。 C++中调用C函数的实例12345// cHeader.h#ifndef C_HEADER#define C_HEADERvoid print( int i );#endif 12345678//cHeader.c#include &lt;stdio.h&gt;#include &quot;cHeader.h&quot;void print( int i )&#123; printf( &quot;cHeader %d\\n&quot;, i );&#125; 1234567891011//C++.cppextern &quot;C&quot;&#123; #include &quot;cHeader.h&quot;&#125;int main()&#123; print(3); return 0;&#125; 编译执行： 1234gcc -c cHeader.cg++ C++.cpp cHeader.o./a.outcHeader 3 C中调用C++函数的实例12345678910// cppHeader.h#ifndef CPP_HEADER#define CPP_HEADERextern &quot;C&quot; &#123; void print( int i );&#125;#endif 12345678910111213// cppHeader.cpp#include &quot;cppHeader.h&quot;//#include &lt;iostream&gt; //不能有c++专有的头文件，否则无法编译#include &lt;stdio.h&gt;using namespace std;void print( int i )&#123;// cout &lt;&lt; &quot;cppHeader &quot; &lt;&lt; i &lt;&lt; endl; //不能有c++专有的函数，否则无法编译 printf( &quot;%d\\n&quot;, i );&#125; 12345678// c.cextern void print( int i );int main()&#123; print(3); return 0;&#125; 编译执行： 1234g++ -c cppHeader.cppgcc c.c cppHeader.o //不能使用g++ c.c cppHeader.o，否则会出现undefined reference to `print(int)&#x27;./a.out3 若C调用的C++函数中包含了cout等C++符号，则需要做一个中间接口库，对C++库进行二次封装，实例如下： 1234567891011121314151617181920212223242526272829303132// world.cpp#include &lt;iostream&gt;void world( int )&#123; std::cout &lt;&lt; &quot;world&quot; &lt;&lt; std::endl; &#125;/*使用nm命令查看导出的函数，发现world被修饰后的完整名称为T _Z5worldi, C++默认会返回一个整型，所以前面有Tnm -D libworld.so 0000000000201050 B __bss_start U __cxa_atexit w __cxa_finalize0000000000201050 D _edata0000000000201058 B _end00000000000009c8 T _fini w __gmon_start__00000000000007c0 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable w _Jv_RegisterClasses0000000000000935 T _Z5worldi U _ZNSolsEPFRSoS_E U _ZNSt8ios_base4InitC1Ev U _ZNSt8ios_base4InitD1Ev U _ZSt4cout U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_ U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc*/ 1234567891011121314151617181920212223242526272829303132333435363738// mid.cpp#include &lt;iostream&gt;void world(int); // 会以C++风格调用world函数#ifdef __cplusplusextern &quot;C&quot; &#123; // 即使这是一个C++程序，下列这个函数的实现也要以C约定的风格来搞！#endif void m_world() // 会生成C风格函数名 &#123; world(1); &#125;#ifdef __cplusplus&#125;#endif/*使用nm命令查看导出的函数，发现world被修饰后的完整名称为U _Z5worldinm -D libmid.so 0000000000201048 B __bss_start U __cxa_atexit w __cxa_finalize0000000000201048 D _edata0000000000201050 B _end0000000000000884 T _fini w __gmon_start__00000000000006b0 T _init w _ITM_deregisterTMCloneTable w _ITM_registerTMCloneTable w _Jv_RegisterClasses0000000000000815 T m_world U _Z5worldi U _ZNSt8ios_base4InitC1Ev U _ZNSt8ios_base4InitD1Ev*/ 12345678910// test.c#include &lt;stdio.h&gt;int main()&#123; m_world(); return 0;&#125; 执行命令编译执行： 1234567g++ --shared -fPIC -o libworld.so world.cppsudo cp libworld.so /lib/g++ --shared -fPIC -o libmid.so mid.cpp -lworldsudo cp libmid.so /lib/gcc test.c -l mid -o test./testworld 参考文章http://www.cnblogs.com/this-543273659/archive/2011/08/19/2146022.htmlhttps://wenku.baidu.com/view/1a851168aef8941ea66e0510.htmlhttp://www.cppblog.com/wolf/articles/77828.htmlhttp://www.jianshu.com/p/8d3eb96e142a#","raw":null,"content":null,"categories":null,"tags":[{"name":"c","slug":"c","permalink":"http://damotiansheng.github.io/tags/c/"},{"name":"c++","slug":"c","permalink":"http://damotiansheng.github.io/tags/c/"}]},{"title":"装机ubantu","slug":null,"date":"2017-05-09T07:58:00.000Z","updated":null,"comments":null,"path":"装机/2017-05-09/装机ubantu.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1. u盘装ubantu12.042. 左侧栏，打开Ubantu软件中心，搜索chrome，安装之, 如有书签(文件夹)，导入之； windows到收藏夹格式转换:iconv -f gb2312 -t utf-8 -o bookmark-utf-8.htm bookmark.htm 3. 浏览器chrome下载的文件，往往不完整，故，大文件使用firefox来下载，在firefox中添加插件:DownThemAll,然后安装之， 在网页上右击，即可下载，右击-》dta OneClick打开DownThemAll插件; 4. 装一个sougou拼音输入法 http://pinyin.sogou.com/linux/ 下载: sogoupinyin_1.2.0.0056_amd64.deb 步骤如下： 安装指南Ubuntu &#x2F; Ubuntu Kylin 14.04 LTS 版本只需双击下载的 deb 软件包，即可直接安装搜狗输入法。 Ubuntu 12.04 LTS 版本由于 Ubuntu 12.04 LTS 自带的 Fcitx 版本较旧，需要先通过 PPA 升级，才能安装下载的 deb 软件包。 1. 点击左上角的图标打开Dash，输入update-manager，点击更新管理器。 2. 在更新管理器中，选择菜单：设置-&gt;软件源-》其他软件，点击添加...按钮，在弹出的窗口中输入ppa:fcitx-team/nightly， 点击添加源。 3. 然后点击重新载入。 4. 打开Ubuntu软件中心，在搜索栏输入fcitx，将会搜出fcitx，然后按照一般软件安装步骤安装即可完成升级。 5. dpkg -i sogoupinyin_1.2.0.0056_amd64.deb完成安装 6. 注销重新登陆，即可使用搜狗输入法了 5. 安装chrome evernote插件; 下载： http://download.csdn.net/detail/findlyu/8300377 打开chrome，打开“工具”-》扩展程序，然后将Evernote-Web-Clipper_v6.2.6.crx插件拖进来即可完成安装； 6. 安装adt-eclipse注：装系统或三系统，ubantu12.04 64位可以打开ubantu14.04系统的磁盘，并且可以打开其中的应用程序，也可访问windows磁盘，访问其中的资料;","raw":null,"content":null,"categories":null,"tags":[{"name":"ubantu","slug":"ubantu","permalink":"http://damotiansheng.github.io/tags/ubantu/"}]},{"title":"linux下实用命令","slug":null,"date":"2017-05-09T07:51:35.000Z","updated":null,"comments":null,"path":"tools/2017-05-09/linux下实用命令.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1. 查看占用磁盘空间查看文件夹大小: du -h –max-depth&#x3D;0 dirname查看文件大小：du -h filename 2. windows到收藏夹格式转换:iconv -f gb2312 -t utf-8 -o bookmark-utf-8.htm bookmark.htm 3. 去除文件每行的行号（会以空格代替行号）：sed ‘s&#x2F;^[ 0-9]* &#x2F; &#x2F;‘ globalfifo.c &gt; globalfifo1.c注意一条命令中不能有既作为输入，又作为输出，否则会导致文件为空；如sed ‘s&#x2F;^[ 0-9]* &#x2F; &#x2F;‘ globalfifo.c &gt; globalfifo.c，导致文件globalfifo.c为空去除数字以空字符代替：sed ‘s&#x2F;^[ 0-9]* &#x2F;&#x2F;‘ globalfifo.c &gt; globalfifo1.c 4. chown username:uername file; chmod -R 666 dir; cp -r srcdir destdir;5. 强制清空回收站：sudo rm -fr $HOME&#x2F;.local&#x2F;share&#x2F;Trash&#x2F;files&#x2F;*6. 替换代码文件中的中文标点符号，如中文分号；,此时编译会出现:error: stray ‘\\357’ in program123sed &#x27;s/；/;/&#x27; code1.c &gt; code2.c替换代码文件中的中文全角空格符号，,此时编译会出现: error: stray ‘\\200’ in program和error: stray ‘\\343’ in programsed &#x27;s/ / /&#x27; code1.c &gt; code2.c，注意s后门第一个//之间的字符为中文全角空格，第二个//之间的字符为英文空格 7. 将一个文件所有行以tab键开始1sed &#x27;s/^[ ]*/ /&#x27; test4.c &gt; test44.c 其中[]内包含了空格和tab键，最后一个&#x2F;&#x2F;之间的内容为tab键，linux命令行输入tab键:先按Ctrl+v，再按Tab就可以输入了。 8. 杀死除ps和bash的第三个进程123456kill -9 `ps | grep -v bash | grep -v ps | grep -v grep | grep -v awk | awk &#x27;&#123;print $1&#125;&#x27; | grep -v PID`ps输出如下:15088 pts/1 00:00:00 bash31626 pts/1 00:00:00 a.out31636 pts/1 00:00:00 ps 执行上面命令将会杀死a.out 9. 查找某一字符串内容: grep “dm9000” -r * 在当前目录下查找字符串dm900010. 消除文件中的回车1tr -d &#x27;\\015&#x27; &lt; file &gt; newfiel 11. 定位某个文件: find &#x2F;home -name “*.txt” -print用grep搜索一个目录下所有文件中的某个字符串: find &#x2F;usr -type f -print | xargs grep pid_t 12. df -h 查看磁盘使用情况","raw":null,"content":null,"categories":null,"tags":[{"name":"工具","slug":"工具","permalink":"http://damotiansheng.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"hadoop之debug","slug":null,"date":"2017-05-09T07:45:08.000Z","updated":null,"comments":null,"path":"hadoop/2017-05-09/hadoop之debug.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1、hadoop dfsadmin -safemode leave离开安全模式后，eclipse之就可以删除文件了；2、hadoop文件夹下的文件权限不能随便改变，如sudo chmod -R a+rw hadoop&#x2F; 可能会导致datanode启动不了； 从而导致：hadoop dfsadmin -report，输出: 12345678Configured Capacity: 0 (0 KB)Present Capacity: 0 (0 KB)DFS Remaining: 0 (0 KB)DFS Used: 0 (0 KB)DFS Used%: �%Under replicated blocks: 0Blocks with corrupt replicas: 0Missing blocks: 0 总之，那里出问题，看logs文件夹下对应的日志文件 3、Hadoop运行class类出现Exception in thread “main” java.lang.NoClassDefFoundError这个问题一直让我自己写的class类无法再hadoop平台运行，困惑好几天了，看权威指南的进度直接无进展。解决方法是在 conf&#x2F;hadoop-env.sh添加hadoop的类路径export HADOOP_CLASSPATH&#x3D;.还有用javac编译hadoop平台的java代码要用到好多的hadoop的class类，一直写 javac -classpath …很麻烦，可以在 ~&#x2F;.bashrc 中添加如下语句：export CLASSPATH&#x3D;”$CLASSPATH:$HADOOP_HOME&#x2F;hadoop-core-0.20.203.0.jar:$HADOOP_HOME&#x2F;lib&#x2F;commons-cli-1.2.jar” from: http://blog.chinaunix.net/uid-27672830-id-3374186.html","raw":null,"content":null,"categories":null,"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://damotiansheng.github.io/tags/hadoop/"}]},{"title":"读写hdfs代码","slug":null,"date":"2017-05-09T07:41:36.000Z","updated":null,"comments":null,"path":"hadoop/2017-05-09/读写hdfs代码.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"1) 读取hdfs文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// FileSystemCat.java:package main;import java.io.IOException;import java.io.InputStream;import java.net.URI;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IOUtils;public class FileSystemCat &#123; public static void main( String[] args ) &#123; String uri = args[0]; Configuration conf = new Configuration(); FileSystem fs = null; try &#123; fs = FileSystem.get( URI.create(uri), conf ); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; InputStream in = null; try &#123; in = fs.open( new Path(uri) ); IOUtils.copyBytes( in, System.out, 4096, false ); &#125; catch( Exception e ) &#123; &#125; finally &#123; IOUtils.closeStream(in); &#125; return; &#125;&#125; 2) 将本地文件复制到hadoop文件系统123456789101112131415161718192021222324252627282930313233343536373839404142// FileCopyWithProgress.java:package main; import java.io.BufferedInputStream; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStream; import java.net.URI; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IOUtils; import org.apache.hadoop.util.Progressable; public class FileCopyWithProgress &#123; /** * @param args */ public static void main(String[] args) throws Exception&#123; // TODO Auto-generated method stub String localSrc = args[0]; String dst = args[1]; InputStream in = new BufferedInputStream(new FileInputStream(localSrc)); Configuration conf = new Configuration(); FileSystem fs = FileSystem.get(URI.create(dst), conf); OutputStream out = fs.create(new Path(dst), new Progressable()&#123; public void progress()&#123; System.out.print(&quot;.&quot;); &#125; &#125;); IOUtils.copyBytes(in, out, 4096, true); &#125; &#125; $ hadoop FileCopyWithProgress input/1.txt hdfs://localhost/user/2.txt.......上面的点为显示进度 3) URLCat.java1234567891011121314151617181920212223242526272829303132333435363738394041package main;import java.io.IOException;import java.io.InputStream;import java.net.MalformedURLException;import java.net.URL;import org.apache.hadoop.fs.FsUrlStreamHandlerFactory;import org.apache.hadoop.io.IOUtils;public class URLCat &#123; static &#123; URL.setURLStreamHandlerFactory( new FsUrlStreamHandlerFactory() ); &#125; public static void main( String[] args ) &#123; InputStream in = null; try &#123; in = new URL(args[0]).openStream(); IOUtils.copyBytes( in, System.out, 4096, false ); &#125; catch( Exception e ) &#123; &#125; finally &#123; IOUtils.closeStream(in); &#125; return; &#125;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://damotiansheng.github.io/tags/hadoop/"}]},{"title":"完整启动hadoop步骤","slug":null,"date":"2017-05-09T07:33:16.000Z","updated":null,"comments":null,"path":"hadoop/2017-05-09/完整启动hadoop步骤.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"目的有时启动hadoop会出现各种问题，现给出完整的启动hadoop步骤，搭建hadoop,请参考：http://blog.csdn.net/zhaoyl03/article/details/8657104。 启动步骤如下 1）jps查看namenode等是否已经启动，若是，则kill之； 2）切换用户: su - hadoop(因为开始我执行过: su chown -R hadoop:hadoop hadoop，即将hadoop目录属主和用户组全部改为hadoop用户和hadoop用户组了,为了防止权限问题，切换为hadoop用户); 3）清空hadoop.tmp.dir目录和&#x2F;tmp&#x2F;hadoop：查看conf&#x2F;core-site.xml文件，查看hadoop.tmp.dir值，我的为&#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmpsudo rm -rf &#x2F;tmp&#x2F;hadoopsudo rm -rf &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;tmp&#x2F;* 4）ps -e | grep namenode等，ps -e | grep java，kill掉java进程等相关进程，否则启动时可能会出现: ERROR org.apache.hadoop.hdfs.server.namenode.NameNode: java.io.IOException: Cannot lock storage &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;datalog1. The directory is already locked. 5）格式化: bin&#x2F;hadoop namenode -format出现下面相关内容表示成功：15&#x2F;05&#x2F;28 15:52:25 INFO namenode.NameNode: SHUTDOWN_MSG:&#x2F;************************************************************ SHUTDOWN_MSG: Shutting down NameNode at hulin-HP-Pro-3380-MT&#x2F;127.0.1.1************************************************************&#x2F; 6）启动: bin&#x2F;start-all.sh 7）jps查看java进程，启动成功如下：27950 NameNode28811 TaskTracker28896 Jps28559 JobTracker28469 SecondaryNameNode28199 DataNode 8）若某一进程启动失败，查看logs文件夹下的.log文件，找出异常，百度谷歌之即可解决；","raw":null,"content":null,"categories":null,"tags":[{"name":"hadoop","slug":"hadoop","permalink":"http://damotiansheng.github.io/tags/hadoop/"}]},{"title":"hexo本地测试github博客","slug":null,"date":"2017-04-19T08:51:54.000Z","updated":null,"comments":null,"path":"hexo/2017-04-19/hexo本地测试github博客.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"执行如下命令12345678910git clone https://github.com/damotiansheng/damotiansheng.github.io.source.gitcd damotiansheng.github.io.source/cp _config.yml _config.yml.baknpm install hexo --savenpm install hexo-server --savehexo init . //会覆盖_config.ymlcp _config.yml.bak _config.ymlhexo cleanhexo ghexo server 验证访问http://localhost:4000/查看效果即可","raw":null,"content":null,"categories":null,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damotiansheng.github.io/tags/hexo/"}]},{"title":"hexo错误集","slug":null,"date":"2017-04-14T10:29:31.000Z","updated":null,"comments":null,"path":"hexo/2017-04-14/hexo错误集.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"问题1：出现：ERROR Plugin load failed: hexo-generator-json-content解决：把node升级到6.0版本及以上，此为还要将.travis.yml中的nodejs版本改为6；参考文章：http://www.cnblogs.com/arvin0/p/6664239.html 解决步骤 1）node-v6.2.0-linux-x64.tar.gz 2）.&#x2F;npm install g hexo安装完后，node-v6.2.0-linux-x64&#x2F;bin&#x2F;node_modules目录即有hexo可执行文件了。 3）将.travis.yum中的nodejs版本改为6 4）博客根目录执行：npm i hexo-generator-json-content –save 5）发布","raw":null,"content":null,"categories":null,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damotiansheng.github.io/tags/hexo/"}]},{"title":"nginx总结","slug":null,"date":"2017-04-11T07:29:31.000Z","updated":null,"comments":null,"path":"uncategorized/2017-04-11/nginx总结.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"前言通过阅读网上nginx相关博客以及下载的nginx源码，对nginx有了一定的了解，现进行一些总结，总结如下所示。 调试1）gdb -p pid进行调试pid进程；2）gdb不停收到sigtrap信号：设置断点之后，有时总会收到上面的信号，导致无法执行到断点位置，解决方法，在收到该信号时，执行：set $ps&amp;&#x3D;~(1&lt;&lt;8)即可。 使用内存池思想新来连接直接从连接结构体内存池取一个结构体用，释放则挂上去即可，无须每次来连接就申请内存，且这里为大块内存，避免了内存碎片，连接结构体里面有事件结构体，监听读写也只需加入该结构体中的信息到epoll即可，无需每次监听某个读写事件都申请内存。如：Ngxin对于每个建立成功的TCP连接会预先分配一个内存池。也就是ngx_connection_t结构体中的pool，在处理HTTP请求时，将会为每个请求分配一个内存池。 使用位域节约空间。使用accept锁避免惊群问题。使用红黑树处理超时事件。master进程管理多个worker进程，多个worker进程处理连接，并发量加大。使用自己缓存的时间，避免gettimeofday（需要发送中断给linux内核，内核需要做进程间切换来处理这个调用）系统调用的频繁调用。采用事件驱动模型，依据不同的运行平台，选择合适的IO复用函数，如epoll。具有自动重启worker进程的功能，即发现某个worker进程退出了，自动开启一个新的worker进程。具有不中断服务的情况下平滑升级nginx程序的功能。具有不中断服务器的情况下重新加载配置文件，使配置文件马上生效的功能。采用模块化思想，可以添加&#x2F;删除外部模块，具有更大的扩展性。采用socketpair创建channel[2]用于master与worker以及worker之间（只不过这里没有通信）的通信。可以托管网站以及作为反向代理。nginx使用非阻塞模式，将一个HTTP请求分成多个阶段，细化处理，并不会阻塞在某一个读&#x2F;写上，而是阻塞在epoll上以提高并发。创建一个监听fd（调用socket，bing，listen）之后，只要某个进程能得到该fd，该进程就可以accept它得到连接。nginx通过尽量减少内存拷贝来提高效率在整个解析http请求的状态机中始终遵循着两条重要的原则：减少内存拷贝和回溯。内存拷贝是一个相对比较昂贵的操作，大量的内存拷贝会带来较低的运行时效率。nginx在需要做内存拷贝的地方尽量只拷贝内存的起始和结束地址而不是内存本身，这样做的话仅仅只需要两个赋值操作而已，大大降低了开销，当然这样带来的影响是后续的操作不能修改内存本身，如果修改的话，会影响到所有引用到该内存区间的地方，所以必须很小心的管理，必要的时候需要拷贝一份。这里不得不提到nginx中最能体现这一思想的数据结构，ngx_buf_t，它用来表示nginx中的缓存，在很多情况下，只需要将一块内存的起始地址和结束地址分别保存在它的pos和last成员中，再将它的memory标志置1，即可表示一块不能修改的内存区间，在另外的需要一块能够修改的缓存的情形中，则必须分配一块所需大小的内存并保存其起始地址，再将ngx_bug_t的temprary标志置1，表示这是一块能够被修改的内存区域。 一个nginx进程可以并发的处理处于不同阶段的多个请求。nginx使用到的进程间通信和同步方法进程间通信：套接字、共享内存、信号；同步方法：原子操作、信号量、文件锁； nginx中的负载均衡算法实现代码很不错，如加权轮询算法和IP哈希算法，详情见博客：http://blog.csdn.net/column/details/nginxroad.html注：这里的负载均衡算法指的是如何从一些后台服务器和备用服务器中选择一台服务器作为处理请求的服务器。 分配内存时会进行内存对齐，如ngx_pmemalign函数。优秀的数据结构红黑树ngx_rbtree_t、基数树ngx_radix_tree_t（字典树）、动态数组ngx_array_t、单向链表ngx_list_t、双向链表ngx_queue_t、哈希表ngx_hash_t、缓冲区链表ngx_chain_t、内存池ngx_pool_t等，各种实现值得参考。 nginx针对http请求数据无法一次性读取完时如何处理该http请求？ngx_event_t rev，rev-&gt;data保存ngx_connection_t c指针，ngx_http_wait_request_handler函数中会将c-&gt;data设置为ngx_http_request_t指针，代表当前处理的请求，这样当用户来请求了，而数据一次性无法读取完，设置对应阶段的回调函数，当再次有数据到来时，nginx会通过rev得到先前的请求ngx_http_request_t，从而得到先前已经读取到的数据，这些数据是保存在ngx_http_request_t结构体中的。 nginx系列博客：http://blog.csdn.net/yusiguyuan/article/category/2091295http://blog.csdn.net/column/details/nginxroad.htmlhttp://blog.csdn.net/jy02326166/article/category/2332871http://blog.csdn.net/livelylittlefishhttp://blog.csdn.net/chen19870707/article/category/2647301","raw":null,"content":null,"categories":null,"tags":[{"name":"nginx","slug":"nginx","permalink":"http://damotiansheng.github.io/tags/nginx/"}]},{"title":"storage服务器与tracker服务器的一次命令处理过程","slug":null,"date":"2016-12-10T08:52:25.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-10/storage服务器与tracker服务器的一次命令处理过程.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"本篇文章简单介绍下storage server(client端)向tracker server(server端)发送一个命令，然后server端处理命令，client端得到结果的流程。 具体过程storage server通过向server端建立连接，发送一个带包头的数据包，tracker server主线程监听得到该fd，并将该fd按轮询写入到某一个管道，从而选择一个work线程来处理，该work线程调用recv_notify_read函数得到fd，接着设置READ事件并使用IO复用函数（如epoll）进行监听，READ事件的处理函数为client_sock_read，当client端发送命令过来时，该函数被调用，当接收完一个完整的命令包时会调用tracker_deal_task(pTask)函数进行命令的分发处理，调用client_sock_write函数发送response, 发送完毕后，继续监听该fd的读事件，而storage server则会读取得到reponse数据，从而得到命令的结果。 举例来源于storage server发送TRACKER_PROTO_CMD_STORAGE_GET_SERVER_ID命令：storage进程main-&gt;storage_func_init-&gt;storage_func_init-&gt;tracker_get_my_server_id-&gt;tracker_get_storage_id-&gt;tcpsenddata_nb(TRACKER_PROTO_CMD_STORAGE_GET_SERVER_ID)&#x2F;fdfs_recv_responsetracker作服务端处理：tracker_deal_task(TRACKER_PROTO_CMD_STORAGE_GET_SERVER_ID)-&gt;tracker_deal_get_storage_id-&gt;fdfs_get_storage_id_by_ip","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"}]},{"title":"fastdfs之storage主流程","slug":null,"date":"2016-12-04T09:08:51.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-04/fastdfs之storage主流程.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"主要工作相关文章1）思想：与tracker主流程一样，采用主线程监听得到fd,dispatch子线程（默认4个工作线程）进行处理；2）创建的线程数：会创建与tracker server数量相等的report thread,用于向tracker server发送相关信息，会创建4个工作线程用于处理任务，会创建一个调度线程，用于执行一些定期任务，如：log_sync_func，fdfs_binlog_sync_func等，还会创建一些IO读写线程，用于读写目录，默认一个目录有一个读线程和一个写线程，线程函数都为dio_thread_entrance函数；3）主要处理过程：主线程往管道写入得到的连接的相关信息（其实是写入一个fast_task_info地址），工作线程会调用storage_recv_notify_read函数得到该地址，然后依据不同的状态进行不同的处理，具体见storage_recv_notify_read函数； 相关数据结构12345678910111213141516struct nio_thread_data&#123; struct ioevent_puller ev_puller; //IO multiplexing function: poll, kqueue struct fast_timer timer; // time wheel int pipe_fds[2]; //to wake up current thread who owns current nio_thread_data struct fast_task_info *deleted_list; ThreadLoopCallback thread_loop_callback; void *arg; //extra argument pointer&#125;;struct storage_nio_thread_data&#123; struct nio_thread_data thread_data; GroupArray group_array; //FastDHT group array&#125;;每个工作线程对应一个storage_nio_thread_data结构 相关代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407// fdfs_storaged.c-&gt;main函数int main(int argc, char *argv[])&#123; char *conf_filename; int result; int sock; int wait_count; pthread_t schedule_tid; struct sigaction act; ScheduleEntry scheduleEntries[SCHEDULE_ENTRIES_MAX_COUNT]; ScheduleArray scheduleArray; char pidFilename[MAX_PATH_SIZE]; bool stop; if (argc &lt; 2) &#123; usage(argv[0]); return 1; &#125; g_current_time = time(NULL); g_up_time = g_current_time; log_init2(); //init the log system trunk_shared_init(); // init the g_fdfs_base64_context global variable conf_filename = argv[1]; if ((result=get_base_path_from_conf_file(conf_filename, g_fdfs_base_path, sizeof(g_fdfs_base_path))) != 0) // get base path from conf_filename &#123; log_destroy(); return result; &#125; snprintf(pidFilename, sizeof(pidFilename), &quot;%s/data/fdfs_storaged.pid&quot;, g_fdfs_base_path); if ((result=process_action(pidFilename, argv[2], &amp;stop)) != 0)// process command: restart/stop/start &#123; if (result == EINVAL) &#123; usage(argv[0]); &#125; log_destroy(); return result; &#125; if (stop) &#123; log_destroy(); return 0; &#125;#if defined(DEBUG_FLAG) &amp;&amp; defined(OS_LINUX) if (getExeAbsoluteFilename(argv[0], g_exe_name, \\ sizeof(g_exe_name)) == NULL) //get the absolute path of exe file saved to g_exe_name &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return errno != 0 ? errno : ENOENT; &#125;#endif daemon_init(false); // set to daemon mode umask(0); memset(g_bind_addr, 0, sizeof(g_bind_addr)); if ((result=storage_func_init(conf_filename, \\ g_bind_addr, sizeof(g_bind_addr))) != 0) // parse the conf_filename and get some values saved to global variable &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; //*g_bind_addr = &#x27;\\0&#x27;, g_server_port=23000 // socketServer to finish socket, bind, listen sock = socketServer(g_bind_addr, g_server_port, &amp;result); if (sock &lt; 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // tcpsetserveropt: set send/recv timeout and keepalive parameter if ((result=tcpsetserveropt(sock, g_fdfs_network_timeout)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; if ((result=write_to_pid_file(pidFilename)) != 0) &#123; log_destroy(); return result; &#125; // create base_path and the sync path, create file: binlog.000(default), init the sync_thread_lock if ((result=storage_sync_init()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;storage_sync_init fail, program exit!&quot;, __LINE__); g_continue_flag = false; return result; &#125; // init the lock of reporter_thread_lock, clear g_storage_servers and g_sorted_storages if ((result=tracker_report_init()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;tracker_report_init fail, program exit!&quot;, __LINE__); g_continue_flag = false; return result; &#125; //create 4 work thread default, init some lock, build a task object(fast_task_info) pool(g_free_queue) if ((result=storage_service_init()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;storage_service_init fail, program exit!&quot;, __LINE__); g_continue_flag = false; return result; &#125; // init the rand generator if ((result=set_rand_seed()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;set_rand_seed fail, program exit!&quot;, __LINE__); g_continue_flag = false; return result; &#125; memset(&amp;act, 0, sizeof(act)); sigemptyset(&amp;act.sa_mask); act.sa_handler = sigUsrHandler; // sigUsrHandler do nothing if(sigaction(SIGUSR1, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGUSR2, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = sigHupHandler; // set g_log_context.rotate_immediately to true if(sigaction(SIGHUP, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = SIG_IGN; if(sigaction(SIGPIPE, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = sigQuitHandler; if(sigaction(SIGINT, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGTERM, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGQUIT, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#if defined(DEBUG_FLAG)/*#if defined(OS_LINUX) memset(&amp;act, 0, sizeof(act)); act.sa_sigaction = sigSegvHandler; act.sa_flags = SA_SIGINFO; if (sigaction(SIGSEGV, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGABRT, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#endif*/ memset(&amp;act, 0, sizeof(act)); sigemptyset(&amp;act.sa_mask); act.sa_handler = sigDumpHandler; if(sigaction(SIGUSR1, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGUSR2, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#endif#ifdef WITH_HTTPD if (!g_http_params.disabled) &#123; if ((result=storage_httpd_start(g_bind_addr)) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;storage_httpd_start fail, &quot; \\ &quot;program exit!&quot;, __LINE__); return result; &#125; &#125;#endif // create some child thread, a thread conrresoponds to one tracker server if ((result=tracker_report_thread_start()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;tracker_report_thread_start fail, &quot; \\ &quot;program exit!&quot;, __LINE__); g_continue_flag = false; storage_func_destroy(); log_destroy(); return result; &#125; scheduleArray.entries = scheduleEntries; scheduleArray.count = 0; memset(scheduleEntries, 0, sizeof(scheduleEntries)); INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_sync_log_buff_interval, log_sync_func, &amp;g_log_context); scheduleArray.count++; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_sync_binlog_buff_interval, fdfs_binlog_sync_func, NULL); scheduleArray.count++; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_sync_stat_file_interval, fdfs_stat_file_sync_func, NULL); scheduleArray.count++; if (g_if_use_trunk_file) &#123; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, 1, trunk_binlog_sync_func, NULL); scheduleArray.count++; &#125; if (g_use_access_log) &#123; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_sync_log_buff_interval, log_sync_func, &amp;g_access_log_context); scheduleArray.count++; if (g_rotate_access_log) &#123; INIT_SCHEDULE_ENTRY_EX(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, g_access_log_rotate_time, 24 * 3600, log_notify_rotate, &amp;g_access_log_context); scheduleArray.count++; if (g_log_file_keep_days &gt; 0) &#123; log_set_keep_days(&amp;g_access_log_context, g_log_file_keep_days); INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, 1, 0, 0, 24 * 3600, log_delete_old_files, &amp;g_access_log_context); scheduleArray.count++; &#125; &#125; &#125; if (g_rotate_error_log) &#123; INIT_SCHEDULE_ENTRY_EX(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, g_error_log_rotate_time, 24 * 3600, log_notify_rotate, &amp;g_log_context); scheduleArray.count++; if (g_log_file_keep_days &gt; 0) &#123; log_set_keep_days(&amp;g_log_context, g_log_file_keep_days); INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, 1, 0, 0, 24 * 3600, log_delete_old_files, &amp;g_log_context); scheduleArray.count++; &#125; &#125; // create a thread to schedule log_sync_func,fdfs_stat_file_sync_func and so on if ((result=sched_start(&amp;scheduleArray, &amp;schedule_tid, \\ g_thread_stack_size, (bool * volatile)&amp;g_continue_flag)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // set current group and user of current process if ((result=set_run_by(g_run_by_group, g_run_by_user)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // create read and write thread: dio_thread_entrance for every store_path, // one path has a read thread and a write thread default if ((result=storage_dio_init()) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; log_set_cache(true); // set g_log_context.log_to_cache to true bTerminateFlag = false; bAcceptEndFlag = false; storage_accept_loop(sock); // enter main thread loop, accept to get fd, and wakeup child thread to process bAcceptEndFlag = true; fdfs_binlog_sync_func(NULL); //binlog fsync if (g_schedule_flag) &#123; pthread_kill(schedule_tid, SIGINT); &#125; storage_terminate_threads(); // wakeup work thread to quit storage_dio_terminate(); // terminate the io thread kill_tracker_report_threads(); // kill report thread kill_storage_sync_threads(); wait_count = 0; while (g_storage_thread_count != 0 || \\ g_dio_thread_count != 0 || \\ g_tracker_reporter_count &gt; 0 || \\ g_schedule_flag) &#123;/*#if defined(DEBUG_FLAG) &amp;&amp; defined(OS_LINUX) if (bSegmentFault) &#123; sleep(5); break; &#125;#endif*/ usleep(10000); if (++wait_count &gt; 6000) &#123; logWarning(&quot;waiting timeout, exit!&quot;); break; &#125; &#125; tracker_report_destroy(); storage_service_destroy(); storage_sync_destroy(); storage_func_destroy(); if (g_if_use_trunk_file) &#123; trunk_sync_destroy(); storage_trunk_destroy(); &#125; logInfo(&quot;exit normally.\\n&quot;); log_destroy(); delete_pid_file(pidFilename); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269// 主线程函数// storage server main thread, accept to get the fd, save some info, and write the address of (struct fast_task_info),// it contains the fdstatic void *accept_thread_entrance(void* arg)&#123; int server_sock; int incomesock; struct sockaddr_in inaddr; socklen_t sockaddr_len; in_addr_t client_addr; char szClientIp[IP_ADDRESS_SIZE]; long task_addr; struct fast_task_info *pTask; StorageClientInfo *pClientInfo; struct storage_nio_thread_data *pThreadData; server_sock = (long)arg; while (g_continue_flag) &#123; sockaddr_len = sizeof(inaddr); incomesock = accept(server_sock, (struct sockaddr*)&amp;inaddr, \\ &amp;sockaddr_len); if (incomesock &lt; 0) //error &#123; if (!(errno == EINTR || errno == EAGAIN)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;accept failed, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); &#125; continue; &#125; client_addr = getPeerIpaddr(incomesock, \\ szClientIp, IP_ADDRESS_SIZE); if (g_allow_ip_count &gt;= 0) &#123; if (bsearch(&amp;client_addr, g_allow_ip_addrs, \\ g_allow_ip_count, sizeof(in_addr_t), \\ cmp_by_ip_addr_t) == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ip addr %s is not allowed to access&quot;, \\ __LINE__, szClientIp); close(incomesock); continue; &#125; &#125; // set non block for fd if (tcpsetnonblockopt(incomesock) != 0) &#123; close(incomesock); continue; &#125; pTask = free_queue_pop(); // get a free task object from free task object pool(g_free_queue) if (pTask == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;malloc task buff failed&quot;, \\ __LINE__); close(incomesock); continue; &#125; pClientInfo = (StorageClientInfo *)pTask-&gt;arg; // pTask-&gt;arg is pointer to (StorageClientInfo *), see storage_service_init-&gt;free_queue_init_ex func pTask-&gt;event.fd = incomesock; pClientInfo-&gt;stage = FDFS_STORAGE_STAGE_NIO_INIT; //will be used in storage_recv_notify_read function pClientInfo-&gt;nio_thread_index = pTask-&gt;event.fd % g_work_threads; pThreadData = g_nio_thread_data + pClientInfo-&gt;nio_thread_index; strcpy(pTask-&gt;client_ip, szClientIp); task_addr = (long)pTask; // convert address to long, and write the long if (write(pThreadData-&gt;thread_data.pipe_fds[1], &amp;task_addr, \\ sizeof(task_addr)) != sizeof(task_addr)) &#123; close(incomesock); free_queue_push(pTask); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call write failed, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); &#125; else &#123; int current_connections; current_connections = __sync_add_and_fetch(&amp;g_storage_stat.connection. current_count, 1); if (current_connections &gt; g_storage_stat.connection.max_count) &#123; g_storage_stat.connection.max_count = current_connections; &#125; ++g_stat_change_count; &#125; &#125; return NULL;&#125;//工作线程函数// default is 4 threads to call work_thread_entrancestatic void *work_thread_entrance(void* arg)&#123; int result; struct storage_nio_thread_data *pThreadData; pThreadData = (struct storage_nio_thread_data *)arg; if (g_check_file_duplicate) // check duplicate, here just leave it &#123; if ((result=fdht_copy_group_array(&amp;(pThreadData-&gt;group_array),\\ &amp;g_group_array)) != 0) &#123; pthread_mutex_lock(&amp;g_storage_thread_lock); g_storage_thread_count--; pthread_mutex_unlock(&amp;g_storage_thread_lock); return NULL; &#125; &#125; ioevent_loop(&amp;pThreadData-&gt;thread_data, storage_recv_notify_read, task_finish_clean_up, &amp;g_continue_flag); // epoll wait to listen // free free(ioevent-&gt;events) and close(ioevent-&gt;poll_fd) ioevent_destroy(&amp;pThreadData-&gt;thread_data.ev_puller); if (g_check_file_duplicate) &#123; if (g_keep_alive) &#123; fdht_disconnect_all_servers(&amp;(pThreadData-&gt;group_array)); &#125; fdht_free_group_array(&amp;(pThreadData-&gt;group_array)); &#125; if ((result=pthread_mutex_lock(&amp;g_storage_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; g_storage_thread_count--; if ((result=pthread_mutex_unlock(&amp;g_storage_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; logDebug(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;nio thread exited, thread count: %d&quot;, \\ __LINE__, g_storage_thread_count); return NULL;&#125;void storage_recv_notify_read(int sock, short event, void *arg)&#123; struct fast_task_info *pTask; StorageClientInfo *pClientInfo; long task_addr; int64_t remain_bytes; int bytes; int result; while (1) &#123; // read a address of buffer, it is the address of (struct fast_task_info), see accept_thread_entrance func if ((bytes=read(sock, &amp;task_addr, sizeof(task_addr))) &lt; 0) &#123; if (!(errno == EAGAIN || errno == EWOULDBLOCK)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call read failed, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); &#125; break; &#125; else if (bytes == 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call read failed, end of file&quot;, __LINE__); break; &#125; pTask = (struct fast_task_info *)task_addr; pClientInfo = (StorageClientInfo *)pTask-&gt;arg; if (pTask-&gt;event.fd &lt; 0) //quit flag &#123; return; &#125; /* //logInfo(&quot;=====thread index: %d, pTask-&gt;event.fd=%d&quot;, \\ pClientInfo-&gt;nio_thread_index, pTask-&gt;event.fd); */ if (pClientInfo-&gt;stage &amp; FDFS_STORAGE_STAGE_DIO_THREAD) &#123; pClientInfo-&gt;stage &amp;= ~FDFS_STORAGE_STAGE_DIO_THREAD; &#125; switch (pClientInfo-&gt;stage) &#123; case FDFS_STORAGE_STAGE_NIO_INIT: result = storage_nio_init(pTask); break; case FDFS_STORAGE_STAGE_NIO_RECV: pTask-&gt;offset = 0; remain_bytes = pClientInfo-&gt;total_length - \\ pClientInfo-&gt;total_offset; if (remain_bytes &gt; pTask-&gt;size) &#123; pTask-&gt;length = pTask-&gt;size; &#125; else &#123; pTask-&gt;length = remain_bytes; &#125; if (set_recv_event(pTask) == 0) &#123; client_sock_read(pTask-&gt;event.fd, IOEVENT_READ, pTask); &#125; result = 0; break; case FDFS_STORAGE_STAGE_NIO_SEND: result = storage_send_add_event(pTask); break; case FDFS_STORAGE_STAGE_NIO_CLOSE: result = EIO; //close this socket break; default: logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;invalid stage: %d&quot;, __LINE__, \\ pClientInfo-&gt;stage); result = EINVAL; break; &#125; if (result != 0) &#123; add_to_deleted_list(pTask); &#125; &#125;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"}]},{"title":"fastdfs之超时事件的处理","slug":null,"date":"2016-12-04T06:52:34.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-04/fastdfs之超时事件的处理.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"思想fastdfs有这样的一个需求，设置一个超时时间，时间到了，自动调用某个函数，其实现的思想有点像Timing wheel的思想，构造一个60（默认）个格子的循环队列，插入超时事件时，插入到(该事件超时时间-循环队列基准时间)%60的对应格子上去，每个格子是一个双向链表，接着采用epoll IO复用函数，1秒后，epoll超时返回，然后依据循环队列中的当前时间，遍历该循环队列，直到循环队列中的当前时间等于当前系统时间，遍历时，判断事件是否超时，将所有已经超时的事件提取出来（从循环队列中删除），构造成链表，接着遍历该链表，依次调用超时事件的回调函数，达到超时事件的处理；Timing wheel1Timing wheel2 相关数据结构123456789101112131415161718192021222324252627typedef struct fast_timer_entry &#123; int64_t expires; void *data; struct fast_timer_entry *prev; struct fast_timer_entry *next; bool rehash;&#125; FastTimerEntry; // pre and next to construct a double linked listtypedef struct fast_timer_slot &#123; struct fast_timer_entry head;&#125; FastTimerSlot;typedef struct fast_timer &#123; int slot_count; //time wheel slot count, default is 60 int64_t base_time; //base time for slot 0, set to current time， 基准事件 int64_t current_time; //set to current time FastTimerSlot *slots; //the size is sizeof(FastTimerSlot) * slot_count&#125; FastTimer;#define TIMER_GET_SLOT_INDEX(timer, expires) \\ (((expires) - timer-&gt;base_time) % timer-&gt;slot_count)#define TIMER_GET_SLOT_POINTER(timer, expires) \\ (timer-&gt;slots + TIMER_GET_SLOT_INDEX(timer, expires)) 相关代码&#x2F;&#x2F; fast_timer.h&#x2F;fast_timer.c&#x2F;&#x2F; init the timer, slot_count&#x3D;60int fast_timer_init(FastTimer *timer, const int slot_count, const int64_t current_time){ int bytes; if (slot_count &lt;&#x3D; 0 || current_time &lt;&#x3D; 0) { return EINVAL; } timer-&gt;slot_count &#x3D; slot_count; &#x2F;&#x2F;default is 60 timer-&gt;base_time &#x3D; current_time; &#x2F;&#x2F;base time for slot 0 timer-&gt;current_time &#x3D; current_time; bytes &#x3D; sizeof(FastTimerSlot) * slot_count; timer-&gt;slots &#x3D; (FastTimerSlot *)malloc(bytes); if (timer-&gt;slots &#x3D;&#x3D; NULL) { return errno !&#x3D; 0 ? errno : ENOMEM; } memset(timer-&gt;slots, 0, bytes); return 0; } int ioevent_loop(struct nio_thread_data *pThreadData, IOEventCallback recv_notify_callback, TaskCleanUpCallback clean_up_callback, volatile bool *continue_flag){ int result; IOEventEntry ev_notify; FastTimerEntry head; struct fast_task_info *pTask; time_t last_check_time; int count; memset(&amp;ev_notify, 0, sizeof(ev_notify)); ev_notify.fd = pThreadData-&gt;pipe_fds[0]; ev_notify.callback = recv_notify_callback; if (ioevent_attach(&amp;pThreadData-&gt;ev_puller, pThreadData-&gt;pipe_fds[0], IOEVENT_READ, &amp;ev_notify) != 0) &#123; result = errno != 0 ? errno : ENOMEM; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ioevent_attach fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; pThreadData-&gt;deleted_list = NULL; last_check_time = g_current_time; while (*continue_flag) &#123; // one seconds later, ioevent_poll will return pThreadData-&gt;ev_puller.iterator.count = ioevent_poll(&amp;pThreadData-&gt;ev_puller); //若没有fd就绪，1秒后会超时返回（ioevent_init函数设置了timeout为1秒） if (pThreadData-&gt;ev_puller.iterator.count &gt; 0) &#123; deal_ioevents(&amp;pThreadData-&gt;ev_puller); &#125; else if (pThreadData-&gt;ev_puller.iterator.count &lt; 0) // error occured &#123; result = errno != 0 ? errno : EINVAL; if (result != EINTR) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ioevent_poll fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; &#125; // timeout, 1 second later if (pThreadData-&gt;deleted_list != NULL) // cleanup task callback is not null &#123; count = 0; while (pThreadData-&gt;deleted_list != NULL) &#123; pTask = pThreadData-&gt;deleted_list; pThreadData-&gt;deleted_list = pTask-&gt;next; clean_up_callback(pTask); count++; &#125; logDebug(&quot;cleanup task count: %d&quot;, count); &#125; if (g_current_time - last_check_time &gt; 0) &#123; last_check_time = g_current_time; // the unit of g_current_time is seconds count = fast_timer_timeouts_get( &amp;pThreadData-&gt;timer, g_current_time, &amp;head); // get the expire event count，得到已经超时的事件 if (count &gt; 0) // timeout event has been saved to head &#123; deal_timeouts(&amp;head); // process the timeout event，处理超时事件 &#125; &#125; if (pThreadData-&gt;thread_loop_callback != NULL) &#123; pThreadData-&gt;thread_loop_callback(pThreadData); // call this function every one loop &#125; &#125; return 0; } &#x2F;&#x2F; save expired FastTimerEntry to headint fast_timer_timeouts_get(FastTimer *timer, const int64_t current_time, FastTimerEntry *head){ FastTimerSlot *slot; FastTimerEntry *entry; FastTimerEntry *first; FastTimerEntry *last; FastTimerEntry *tail; int count; head-&gt;prev &#x3D; NULL; head-&gt;next &#x3D; NULL; if (timer-&gt;current_time &gt;&#x3D; current_time) &#x2F;&#x2F; don’t timeout, just return { return 0; } first &#x3D; NULL; last &#x3D; NULL; tail &#x3D; head; count &#x3D; 0; while (timer-&gt;current_time &lt; current_time) { slot &#x3D; TIMER_GET_SLOT_POINTER(timer, timer-&gt;current_time++); &#x2F;&#x2F; entry &#x3D; slot-&gt;head.next; while (entry != NULL) &#123; if (entry-&gt;expires &gt;= current_time) //not expired &#123; if (first != NULL) &#123; first-&gt;prev-&gt;next = entry; entry-&gt;prev = first-&gt;prev; tail-&gt;next = first; first-&gt;prev = tail; tail = last; first = NULL; &#125; if (entry-&gt;rehash) &#123; last = entry; entry = entry-&gt;next; last-&gt;rehash = false; fast_timer_remove(timer, last); fast_timer_add(timer, last); continue; &#125; &#125; else //expired &#123; count++; if (first == NULL) &#123; first = entry; &#125; &#125; last = entry; entry = entry-&gt;next; &#125; if (first != NULL) &#123; first-&gt;prev-&gt;next = NULL; tail-&gt;next = first; first-&gt;prev = tail; tail = last; first = NULL; &#125; } if (count &gt; 0) { tail-&gt;next &#x3D; NULL; } return count;} &#x2F;&#x2F;插入超时事件&#x2F;&#x2F; add entry to timer according to entry-&gt;expiresint fast_timer_add(FastTimer *timer, FastTimerEntry *entry){ FastTimerSlot *slot; slot &#x3D; TIMER_GET_SLOT_POINTER(timer, entry-&gt;expires &gt; timer-&gt;current_time ? entry-&gt;expires : timer-&gt;current_time); entry-&gt;next &#x3D; slot-&gt;head.next; if (slot-&gt;head.next !&#x3D; NULL) { slot-&gt;head.next-&gt;prev &#x3D; entry; } entry-&gt;prev &#x3D; &amp;slot-&gt;head; slot-&gt;head.next &#x3D; entry; entry-&gt;rehash &#x3D; false; return 0;}","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"},{"name":"超时事件","slug":"超时事件","permalink":"http://damotiansheng.github.io/tags/%E8%B6%85%E6%97%B6%E4%BA%8B%E4%BB%B6/"}]},{"title":"fastdfs之事件监听","slug":null,"date":"2016-12-04T06:25:51.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-04/fastdfs之事件监听.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"思想fastdfs需要监听某个fd的事件，当fd就绪时自动调用某个函数进行处理，其思想是将该事件的回调函数，fd保存到epoll_event结构体中，当该fd就绪时就可得到该结构体，从而调用该回调函数；epoll机制 相关数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef struct ioevent_puller &#123; int size; //set to g_max_connections + 2,default is 256+2, max events (fd) , equal as the parameter of epoll_create int extra_events; int poll_fd; // poll_fd = epoll_create(ioevent-&gt;size)/*When successful, epoll_wait() returns the number of file descriptors ready for the requested I/O, or zero if no file descriptor became ready during the requested timeout milliseconds. When an error occurs, epoll_wait() returns -1 and errno is set appropriately.*/ struct &#123; int index; int count; // count=epoll_wait(...) &#125; iterator; //for deal event loop#if IOEVENT_USE_EPOLL struct epoll_event *events; // the size is ( size * sizeof(struct epoll_event) ) int timeout; // default is 1000#elif IOEVENT_USE_KQUEUE struct kevent *events; struct timespec timeout; int care_events;#elif IOEVENT_USE_PORT port_event_t *events; timespec_t timeout;#endif&#125; IOEventPoller;typedef void (*IOEventCallback) (int sock, short event, void *arg);typedef struct ioevent_entry&#123; int fd; // it will be added to nio_thread_data-&gt;ev_puller FastTimerEntry timer; // for event timeout, it will be added to nio_thread_data-&gt;timer IOEventCallback callback;&#125; IOEventEntry;#if IOEVENT_USE_EPOLL #define IOEVENT_GET_EVENTS(ioevent, index) \\ ioevent-&gt;events[index].events#if IOEVENT_USE_EPOLL #define IOEVENT_GET_DATA(ioevent, index) \\ ioevent-&gt;events[index].data.ptr 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235//初始化//ioevent_init(&amp;pThreadData-&gt;ev_puller,g_max_connections + 2, 1000, 0) // 1000毫秒// size=256+2, timeout_ms=1000, extra_events=0// ioevent_init(&amp;pThreadData-&gt;ev_puller, g_max_connections + 2, 1000, 0)int ioevent_init(IOEventPoller *ioevent, const int size, const int timeout_ms, const int extra_events)&#123; int bytes; ioevent-&gt;size = size; ioevent-&gt;extra_events = extra_events; ioevent-&gt;iterator.index = 0; ioevent-&gt;iterator.count = 0;#if IOEVENT_USE_EPOLL ioevent-&gt;poll_fd = epoll_create(ioevent-&gt;size); bytes = sizeof(struct epoll_event) * size; ioevent-&gt;events = (struct epoll_event *)malloc(bytes);#elif IOEVENT_USE_KQUEUE ioevent-&gt;poll_fd = kqueue(); bytes = sizeof(struct kevent) * size; ioevent-&gt;events = (struct kevent *)malloc(bytes); ioevent-&gt;care_events = 0;#elif IOEVENT_USE_PORT ioevent-&gt;poll_fd = port_create(); bytes = sizeof(port_event_t) * size; ioevent-&gt;events = (port_event_t *)malloc(bytes);#endif if (ioevent-&gt;events == NULL) &#123; return errno != 0 ? errno : ENOMEM; &#125; // set the ioevent-&gt;timeout to timeout_ms ioevent_set_timeout(ioevent, timeout_ms); // 设置超时时间为1秒 return 0;&#125;//事件监听处理循环//ioevent_loop(pThreadData, recv_notify_read, task_finish_clean_up, &amp;g_continue_flag);/*ioevent_loop(pThreadData, recv_notify_read, task_finish_clean_up, &amp;g_continue_flag); // g_continue_flag is true default*/int ioevent_loop(struct nio_thread_data *pThreadData, IOEventCallback recv_notify_callback, TaskCleanUpCallback clean_up_callback, volatile bool *continue_flag)&#123; int result; IOEventEntry ev_notify; FastTimerEntry head; struct fast_task_info *pTask; time_t last_check_time; int count; memset(&amp;ev_notify, 0, sizeof(ev_notify)); ev_notify.fd = pThreadData-&gt;pipe_fds[0]; ev_notify.callback = recv_notify_callback; if (ioevent_attach(&amp;pThreadData-&gt;ev_puller, pThreadData-&gt;pipe_fds[0], IOEVENT_READ, &amp;ev_notify) != 0) &#123; result = errno != 0 ? errno : ENOMEM; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ioevent_attach fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; pThreadData-&gt;deleted_list = NULL; last_check_time = g_current_time; while (*continue_flag) &#123; // one seconds later, ioevent_poll will return pThreadData-&gt;ev_puller.iterator.count = ioevent_poll(&amp;pThreadData-&gt;ev_puller); if (pThreadData-&gt;ev_puller.iterator.count &gt; 0) &#123; deal_ioevents(&amp;pThreadData-&gt;ev_puller); &#125; else if (pThreadData-&gt;ev_puller.iterator.count &lt; 0) // error occured &#123; result = errno != 0 ? errno : EINVAL; if (result != EINTR) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ioevent_poll fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; &#125; // timeout, 1 second later if (pThreadData-&gt;deleted_list != NULL) // cleanup task callback is not null &#123; count = 0; while (pThreadData-&gt;deleted_list != NULL) &#123; pTask = pThreadData-&gt;deleted_list; pThreadData-&gt;deleted_list = pTask-&gt;next; clean_up_callback(pTask); count++; &#125; logDebug(&quot;cleanup task count: %d&quot;, count); &#125; if (g_current_time - last_check_time &gt; 0) &#123; last_check_time = g_current_time; // the unit of g_current_time is seconds count = fast_timer_timeouts_get( &amp;pThreadData-&gt;timer, g_current_time, &amp;head); // get the expire event count if (count &gt; 0) // timeout event has been saved to head &#123; deal_timeouts(&amp;head); // process the timeout event &#125; &#125; if (pThreadData-&gt;thread_loop_callback != NULL) &#123; pThreadData-&gt;thread_loop_callback(pThreadData); // call this function every one loop &#125; &#125; return 0;&#125;int ioevent_poll(IOEventPoller *ioevent)&#123;#if IOEVENT_USE_EPOLL return epoll_wait(ioevent-&gt;poll_fd, ioevent-&gt;events, ioevent-&gt;size, ioevent-&gt;timeout);#elif IOEVENT_USE_KQUEUE return kevent(ioevent-&gt;poll_fd, NULL, 0, ioevent-&gt;events, ioevent-&gt;size, &amp;ioevent-&gt;timeout);#elif IOEVENT_USE_PORT int result; int retval; unsigned int nget = 1; if((retval = port_getn(ioevent-&gt;poll_fd, ioevent-&gt;events, ioevent-&gt;size, &amp;nget, &amp;ioevent-&gt;timeout)) == 0) &#123; result = (int)nget; &#125; else &#123; switch(errno) &#123; case EINTR: case EAGAIN: case ETIME: if (nget &gt; 0) &#123; result = (int)nget; &#125; else &#123; result = 0; &#125; break; default: result = -1; break; &#125; &#125; return result;#else#error port me#endif&#125;//add a fd event to ioevent to listen// ioevent_attach(&amp;pThread-&gt;ev_puller,sock, event, pTask)int ioevent_attach(IOEventPoller *ioevent, const int fd, const int e, void *data)&#123;#if IOEVENT_USE_EPOLL struct epoll_event ev; memset(&amp;ev, 0, sizeof(ev)); ev.events = e | ioevent-&gt;extra_events; ev.data.ptr = data;// 将参数保存到data.ptr中去，依据上面的调用data为IOEventEntry结构类型 return epoll_ctl(ioevent-&gt;poll_fd, EPOLL_CTL_ADD, fd, &amp;ev);#elif IOEVENT_USE_KQUEUE struct kevent ev[2]; int n = 0; if (e &amp; IOEVENT_READ) &#123; EV_SET(&amp;ev[n++], fd, EVFILT_READ, EV_ADD | ioevent-&gt;extra_events, 0, 0, data); &#125; if (e &amp; IOEVENT_WRITE) &#123; EV_SET(&amp;ev[n++], fd, EVFILT_WRITE, EV_ADD | ioevent-&gt;extra_events, 0, 0, data); &#125; ioevent-&gt;care_events = e; return kevent(ioevent-&gt;poll_fd, ev, n, NULL, 0, NULL);#elif IOEVENT_USE_PORT return port_associate(ioevent-&gt;poll_fd, PORT_SOURCE_FD, fd, e, data);#endif&#125;// 事件处理// process the io events by callback function // struct epoll_event: http://blog.csdn.net/wangrice2004/article/details/6651320 static void deal_ioevents(IOEventPoller *ioevent)&#123; int event; IOEventEntry *pEntry; for (ioevent-&gt;iterator.index=0; ioevent-&gt;iterator.index &lt; ioevent-&gt;iterator. count; ioevent-&gt;iterator.index++) &#123; event = IOEVENT_GET_EVENTS(ioevent, ioevent-&gt;iterator.index); pEntry = (IOEventEntry *)IOEVENT_GET_DATA(ioevent, ioevent-&gt;iterator.index); // 得到ioevent_attach设置的data，为IOEventEntry类型 // pEntry is either IOEventEntry(ioevent_loop -&gt; ioevent_attach)or fast_task_info(ioevent_set-&gt;ioevent_attach) // but the first elem of fast_task_info is also IOEventEntry if (pEntry != NULL) // call the callback function, we set data in ioevent_attach func &#123; pEntry-&gt;callback(pEntry-&gt;fd, event, pEntry-&gt;timer.data); // pEntry-&gt;timer.data is fast_task_info(see ioevent_set func) &#125; else &#123; logDebug(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;ignore iovent : %d, index: %d&quot;, __LINE__, event, ioevent-&gt;iterator.index); &#125; &#125;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"},{"name":"epoll","slug":"epoll","permalink":"http://damotiansheng.github.io/tags/epoll/"}]},{"title":"fastdfs之tracker主流程","slug":null,"date":"2016-12-04T05:01:50.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-04/fastdfs之tracker主流程.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"思想相关文章1相关文章2主要思想是采用主线程监听并accept连接（代码中tracker_accept_loop函数可以依据全局变量g_accept_threads而开启多个子线程进行监听，默认只有一个主线程监听），得到fd,然后将该fd写入到某一个管道，而子线程（工作线程）（默认4个）监听到管道的另外一端，其处理函数为recv_notify_read，该函数读取管道得到该fd的值，再次将它加入到某个线程（不一定是当前线程）的监听事件中去，处理函数为client_sock_read，该函数当读完客户端完整的请求数据包时会调用tracker_deal_task函数进行处理，当需要进行写时会调用client_sock_write函数进行处理，这样主线程监听得到连接，交给子线程进行处理； 源码1234567891011相关数据结构struct nio_thread_data&#123; struct ioevent_puller ev_puller; //IO multiplexing function: poll, kqueue struct fast_timer timer; // time wheel int pipe_fds[2]; //to wake up current thread who owns current nio_thread_data struct fast_task_info *deleted_list; ThreadLoopCallback thread_loop_callback; void *arg; //extra argument pointer&#125;;每个工作线程对应一个该结构体，以实现one thread, one loop, 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363//fdfs_trackerd.c-&gt;main函数int main(int argc, char *argv[])&#123; char *conf_filename; int result; int wait_count; int sock; pthread_t schedule_tid; struct sigaction act; ScheduleEntry scheduleEntries[SCHEDULE_ENTRIES_COUNT]; //保存需要定时执行的任务 ScheduleArray scheduleArray; char pidFilename[MAX_PATH_SIZE]; bool stop; if (argc &lt; 2) &#123; usage(argv[0]); return 1; &#125; g_current_time = time(NULL); g_up_time = g_current_time; srand(g_up_time); log_init2(); conf_filename = argv[1]; if ((result=get_base_path_from_conf_file(conf_filename, g_fdfs_base_path, sizeof(g_fdfs_base_path))) != 0) //从配置文件中得到base path &#123; log_destroy(); return result; &#125; snprintf(pidFilename, sizeof(pidFilename), &quot;%s/data/fdfs_trackerd.pid&quot;, g_fdfs_base_path); if ((result=process_action(pidFilename, argv[2], &amp;stop)) != 0) //处理命令： fdfs_trackerd restart/stop/start &#123; if (result == EINVAL) &#123; usage(argv[0]); &#125; log_destroy(); return result; &#125; if (stop) &#123; log_destroy(); return 0; &#125;#if defined(DEBUG_FLAG) &amp;&amp; defined(OS_LINUX) if (getExeAbsoluteFilename(argv[0], g_exe_name, \\ sizeof(g_exe_name)) == NULL) //得到可执行文件的绝对路径，保存到g_exe_name &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return errno != 0 ? errno : ENOENT; &#125;#endif memset(bind_addr, 0, sizeof(bind_addr)); if ((result=tracker_load_from_conf_file(conf_filename, \\ bind_addr, sizeof(bind_addr))) != 0) //得到监听的地址 &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // load last status of tracker last time from file: base_path/data/.tracker_status if ((result=tracker_load_status_from_file(&amp;g_tracker_last_status)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // init the global variable: g_base64_context base64_init_ex(&amp;g_base64_context, 0, &#x27;-&#x27;, &#x27;_&#x27;, &#x27;.&#x27;); // set a rand num if ((result=set_rand_seed()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;set_rand_seed fail, program exit!&quot;, __LINE__); return result; &#125; if ((result=tracker_mem_init()) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; sock = socketServer(bind_addr, g_server_port, &amp;result); if (sock &lt; 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; // set send/recv timeout and keepalive parameter if ((result=tcpsetserveropt(sock, g_fdfs_network_timeout)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; daemon_init(false); //后台进程 umask(0); if ((result=write_to_pid_file(pidFilename)) != 0) &#123; log_destroy(); return result; &#125; // create work thread: work_thread_entrance func // every thread has its event loop if ((result=tracker_service_init()) != 0) //创建工作线程，每个工作线程对应一个nio_thread_data结构体 &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; memset(&amp;act, 0, sizeof(act)); sigemptyset(&amp;act.sa_mask); act.sa_handler = sigUsrHandler; if(sigaction(SIGUSR1, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGUSR2, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = sigHupHandler; if(sigaction(SIGHUP, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = SIG_IGN; if(sigaction(SIGPIPE, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125; act.sa_handler = sigQuitHandler; // send FDFS_PROTO_CMD_QUIT command when caught SIGINT,SIGTERM,SIGQUIT if(sigaction(SIGINT, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGTERM, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGQUIT, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#if defined(DEBUG_FLAG)/*#if defined(OS_LINUX) memset(&amp;act, 0, sizeof(act)); sigemptyset(&amp;act.sa_mask); act.sa_sigaction = sigSegvHandler; act.sa_flags = SA_SIGINFO; if (sigaction(SIGSEGV, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGABRT, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#endif*/ memset(&amp;act, 0, sizeof(act)); sigemptyset(&amp;act.sa_mask); act.sa_handler = sigDumpHandler; if(sigaction(SIGUSR1, &amp;act, NULL) &lt; 0 || \\ sigaction(SIGUSR2, &amp;act, NULL) &lt; 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call sigaction fail, errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); logCrit(&quot;exit abnormally!\\n&quot;); return errno; &#125;#endif#ifdef WITH_HTTPD if (!g_http_params.disabled) &#123; if ((result=tracker_httpd_start(bind_addr)) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;tracker_httpd_start fail, program exit!&quot;, \\ __LINE__); return result; &#125; &#125; if ((result=tracker_http_check_start()) != 0) &#123; logCrit(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;tracker_http_check_start fail, &quot; \\ &quot;program exit!&quot;, __LINE__); return result; &#125;#endif if ((result=set_run_by(g_run_by_group, g_run_by_user)) != 0) &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; scheduleArray.entries = scheduleEntries; scheduleArray.count = 0; memset(scheduleEntries, 0, sizeof(scheduleEntries)); INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_sync_log_buff_interval, log_sync_func, &amp;g_log_context); scheduleArray.count++; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, TIME_NONE, TIME_NONE, TIME_NONE, g_check_active_interval, tracker_mem_check_alive, NULL); scheduleArray.count++; INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, 0, 0, 0, TRACKER_SYNC_STATUS_FILE_INTERVAL, tracker_write_status_to_file, NULL); scheduleArray.count++; if (g_rotate_error_log) &#123; INIT_SCHEDULE_ENTRY_EX(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, g_error_log_rotate_time, 24 * 3600, log_notify_rotate, &amp;g_log_context); scheduleArray.count++; if (g_log_file_keep_days &gt; 0) &#123; log_set_keep_days(&amp;g_log_context, g_log_file_keep_days); INIT_SCHEDULE_ENTRY(scheduleEntries[scheduleArray.count], scheduleArray.count + 1, 1, 0, 0, 24 * 3600, log_delete_old_files, &amp;g_log_context); scheduleArray.count++; &#125; &#125; // create a thread to execute some periodic task above, such as:log_sync_func,tracker_mem_check_alive // tracker_write_status_to_file and so on if ((result=sched_start(&amp;scheduleArray, &amp;schedule_tid, \\ g_thread_stack_size, (bool * volatile)&amp;g_continue_flag)) != 0) //创建调度线程，以定时执行上面的任务：log_sync_func，tracker_mem_check_alive等 &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; if ((result=tracker_relationship_init()) != 0) //初始化主lead &#123; logCrit(&quot;exit abnormally!\\n&quot;); log_destroy(); return result; &#125; log_set_cache(true); //set g_log_context.log_to_cache to true bTerminateFlag = false; bAcceptEndFlag = false; tracker_accept_loop(sock); // the sock is tracker server socket，主线程循环，得到连接，dispatch子线程处理 bAcceptEndFlag = true; if (g_schedule_flag) &#123; pthread_kill(schedule_tid, SIGINT); &#125; tracker_terminate_threads(); #ifdef WITH_HTTPD if (g_http_check_flag) &#123; tracker_http_check_stop(); &#125; while (g_http_check_flag) &#123; usleep(50000); &#125;#endif wait_count = 0; // g_schedule_flag is true means the schedule thread is not ended, see sched_thread_entrance while ((g_tracker_thread_count != 0) || g_schedule_flag) &#123;/*#if defined(DEBUG_FLAG) &amp;&amp; defined(OS_LINUX) if (bSegmentFault) &#123; sleep(5); break; &#125;#endif*/ usleep(10000); if (++wait_count &gt; 3000) &#123; logWarning(&quot;waiting timeout, exit!&quot;); break; &#125; &#125; tracker_mem_destroy(); // free the memory in g_groups and free lock allocated previously tracker_service_destroy(); // wait all child thread to exit tracker_relationship_destroy(); // do nothing logInfo(&quot;exit normally.\\n&quot;); log_destroy(); // destory the log system delete_pid_file(pidFilename); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180//初始化工作线程// create work thread: work_thread_entrance func// http://slucx.blog.chinaunix.net/uid-29504236-id-4556391.html// http://slucx.blog.chinaunix.net/uid-29504236-id-4556487.htmlint tracker_service_init()&#123;#define ALLOC_CONNECTIONS_ONCE 1024 int result; int bytes; int init_connections; struct nio_thread_data *pThreadData; struct nio_thread_data *pDataEnd; pthread_t tid; pthread_attr_t thread_attr; if ((result=init_pthread_lock(&amp;tracker_thread_lock)) != 0) &#123; return result; &#125; if ((result=init_pthread_lock(&amp;lb_thread_lock)) != 0) &#123; return result; &#125; if ((result=init_pthread_attr(&amp;thread_attr, g_thread_stack_size)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;init_pthread_attr fail, program exit!&quot;, __LINE__); return result; &#125; init_connections = g_max_connections &lt; ALLOC_CONNECTIONS_ONCE ? g_max_connections : ALLOC_CONNECTIONS_ONCE; if ((result=free_queue_init_ex(g_max_connections, init_connections, ALLOC_CONNECTIONS_ONCE, TRACKER_MAX_PACKAGE_SIZE, TRACKER_MAX_PACKAGE_SIZE, sizeof(TrackerClientInfo))) != 0) &#123; return result; &#125; // every thread has one nio_thread_data bytes = sizeof(struct nio_thread_data) * g_work_threads; g_thread_data = (struct nio_thread_data *)malloc(bytes ); if (g_thread_data == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;malloc %d bytes fail, errno: %d, error info: %s&quot;, \\ __LINE__, bytes, errno, STRERROR(errno)); return errno != 0 ? errno : ENOMEM; &#125; memset(g_thread_data, 0, bytes); g_tracker_thread_count = 0; pDataEnd = g_thread_data + g_work_threads; // 默认g_work_threads为4 for (pThreadData=g_thread_data; pThreadData&lt;pDataEnd; pThreadData++) &#123; if (ioevent_init(&amp;pThreadData-&gt;ev_puller, g_max_connections + 2, 1000, 0) != 0) // g_max_connections=256，初始化IO复用函数，超时为1秒 &#123; result = errno != 0 ? errno : ENOMEM; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;ioevent_init fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; result = fast_timer_init(&amp;pThreadData-&gt;timer, 2 * g_fdfs_network_timeout, g_current_time); //初始化超时事件time wheel if (result != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;fast_timer_init fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); return result; &#125; if (pipe(pThreadData-&gt;pipe_fds) != 0) //创建管道 &#123; result = errno != 0 ? errno : EPERM; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pipe fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); break; &#125;#if defined(OS_LINUX) if ((result=fd_add_flags(pThreadData-&gt;pipe_fds[0], \\ O_NONBLOCK | O_NOATIME)) != 0) // O_NOATIME: Do not update the file last access time &#123; break; &#125;#else if ((result=fd_add_flags(pThreadData-&gt;pipe_fds[0], \\ O_NONBLOCK)) != 0) &#123; break; &#125;#endif if ((result=pthread_create(&amp;tid, &amp;thread_attr, \\ work_thread_entrance, pThreadData)) != 0) //创建工作线程 &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;create thread failed, startup threads: %d, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, g_tracker_thread_count, \\ result, STRERROR(result)); break; &#125; else &#123; if ((result=pthread_mutex_lock(&amp;tracker_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; g_tracker_thread_count++; //工作线程数量递增 if ((result=pthread_mutex_unlock(&amp;tracker_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; &#125; &#125; pthread_attr_destroy(&amp;thread_attr); return 0;&#125;//工作线程work_thread_entrance// tracker child threadstatic void *work_thread_entrance(void* arg)&#123; int result; struct nio_thread_data *pThreadData; pThreadData = (struct nio_thread_data *)arg; ioevent_loop(pThreadData, recv_notify_read, task_finish_clean_up, &amp;g_continue_flag); // 循环等待事件的到来并处理 ioevent_destroy(&amp;pThreadData-&gt;ev_puller); if ((result=pthread_mutex_lock(&amp;tracker_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; g_tracker_thread_count--; //工作线程数量递减 if ((result=pthread_mutex_unlock(&amp;tracker_thread_lock)) != 0) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call pthread_mutex_lock fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; return NULL;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//主线程// accept a client request and dispatch request to child thread for processingstatic void *accept_thread_entrance(void* arg)&#123; int server_sock; int incomesock; struct sockaddr_in inaddr; socklen_t sockaddr_len; struct nio_thread_data *pThreadData; server_sock = (long)arg; while (g_continue_flag) &#123; sockaddr_len = sizeof(inaddr); incomesock = accept(server_sock, (struct sockaddr*)&amp;inaddr, &amp;sockaddr_len); if (incomesock &lt; 0) //error &#123; if (!(errno == EINTR || errno == EAGAIN)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;accept failed, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); &#125; continue; &#125; pThreadData = g_thread_data + incomesock % g_work_threads; if (write(pThreadData-&gt;pipe_fds[1], &amp;incomesock, \\ sizeof(incomesock)) != sizeof(incomesock)) // 将得到的client fd写入某个管道中，wakeup child thread &#123; close(incomesock); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;call write failed, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); &#125; else &#123; int current_connections; current_connections = __sync_add_and_fetch(&amp;g_connection_stat. current_count, 1); if (current_connections &gt; g_connection_stat.max_count) &#123; g_connection_stat.max_count = current_connections; &#125; &#125; &#125; return NULL;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"}]},{"title":"fastdfs连接池","slug":null,"date":"2016-12-03T09:51:25.000Z","updated":null,"comments":null,"path":"uncategorized/2016-12-03/fastdfs连接池.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"fastdfs连接池 思想为了提高连接速度，fastdfs使用到了连接池，并用hash数组来加速查找，key为ip_port, value为：ConnectionManager（见后面），当需要进行连接某个ip:port时，以该ip_port作为key，到hash数组中查找，得到value:ConnectionManager,该结构中保存了针对该ip:port的已建立连接的socket，第一次连接时，会调用conn_pool_connect_server函数建立连接，当需要关闭某个连接时，会调用conn_pool_close_connection_ex函数来将该连接放入连接池中或者直接关闭该连接，放入连接池中即会插入到hash数组中去，此外还会依据该连接的上次访问时间，如果很久没有访问该连接了，就会关闭该连接，见conn_pool_get_connection函数，通过hash数组+关闭连接时将该连接保存到hash数组中来实现连接池，提高连接速度； 用到的数据结构1234567891011121314151617181920212223242526272829303132333435363738typedef struct&#123; int sock; int port; char ip_addr[INET6_ADDRSTRLEN]; int socket_domain; //socket domain, AF_INET, AF_INET6 or PF_UNSPEC for auto dedect&#125; ConnectionInfo;struct tagConnectionManager;typedef struct tagConnectionNode &#123; ConnectionInfo *conn; // pointer the end of ConnectionNode, see conn_pool_get_connection func struct tagConnectionManager *manager; struct tagConnectionNode *next; // pointer to next ConnectionNode which is the same ip and port in conn time_t atime; //last access time, if &#125; ConnectionNode;// connection pool, key is ip_port, value is ConnectionManager, see conn_pool_get_connection functypedef struct tagConnectionManager &#123; ConnectionNode *head; // head pointer to the first ConnectionNode int total_count; //total connections，已经建立的连接数，超过一定数值时，不会再建立连接 int free_count; //free connections pthread_mutex_t lock;&#125; ConnectionManager;typedef struct tagConnectionPool &#123; HashArray hash_array; //key is ip_port, value is ConnectionManager, see conn_pool_get_key func pthread_mutex_t lock; int connect_timeout; int max_count_per_entry; //0 means no limit /* connections whose the idle time exceeds this time will be closed unit: second */ int max_idle_time; int socket_domain; //socket domain&#125; ConnectionPool; 相关代码connection_pool.h&#x2F;connection_pool.c核心函数：conn_pool_get_connection","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"},{"name":"连接池","slug":"连接池","permalink":"http://damotiansheng.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"}]},{"title":"多个线程监听同一个fd","slug":null,"date":"2016-11-27T08:23:59.000Z","updated":null,"comments":null,"path":"uncategorized/2016-11-27/多个线程监听同一个fd.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"多个线程监听同一个fd测试环境ubantu 12.04 x64 目的多个线程监听同一fd,看看是否会出现问题，连接到来时，是否每个线程都会被唤醒，还是只唤醒一个，每个线程被唤醒的次数是否会相等。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// server.c#include &lt;sys/time.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#define PORT 4321#define BACKLOG 100#define MAXRECVLEN 1024pthread_t tid[10];long cnt[10];void accept_thread_entrance( void* arg );int main(int argc, char *argv[])&#123; char buf[MAXRECVLEN]; int listenfd, connectfd; /* socket descriptors */ struct sockaddr_in server; /* server&#x27;s address information */ struct sockaddr_in client; /* client&#x27;s address information */ socklen_t addrlen; /* Create TCP socket */ if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1) &#123; /* handle exception */ perror(&quot;socket() error. Failed to initiate a socket&quot;); exit(1); &#125; int opt = SO_REUSEADDR; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt)); server.sin_family = AF_INET; server.sin_port = htons(PORT); server.sin_addr.s_addr = htonl(INADDR_ANY); if(bind(listenfd, (struct sockaddr *)&amp;server, sizeof(server)) == -1) &#123; perror(&quot;Bind() error.&quot;); exit(1); &#125; if(listen(listenfd, BACKLOG) == -1) &#123; perror(&quot;listen() error. \\n&quot;); exit(1); &#125; int i = 0; int result; for (i=0; i&lt;5; i++) &#123; cnt[i] = 0; if ((result=pthread_create(&amp;tid[i], NULL, \\ accept_thread, \\ (void *)(long)listenfd)) != 0) &#123; puts(&quot;pthread_create error&quot;); break; &#125; &#125; printf( &quot;%lu, %lu, %lu, %lu, %lu \\n&quot;, tid[0], tid[1], tid[2], tid[3], tid[4] ); //这里的输出与子线程的pthread_self返回值并不一样 while(1); return 0;&#125;pthread_mutex_t mutex;pthread_t childTid[10];int idx = 0;void accept_thread( void* arg )&#123; int listenfd = (long)arg; int connectfd; struct sockaddr_in client; socklen_t addrlen; addrlen = sizeof(client); pthread_mutex_lock(&amp;mutex); childTid[idx++] = pthread_self(); pthread_mutex_unlock(&amp;mutex); while(1) &#123; if((connectfd=accept(listenfd,(struct sockaddr *)&amp;client, &amp;addrlen))==-1) &#123; perror(&quot;accept() error. \\n&quot;); exit(1); &#125; struct timeval tv; gettimeofday(&amp;tv, NULL); printf(&quot;pthread-id=%lu,You got a connection from client&#x27;s ip %s, port %d at time %ld.%ld\\n&quot;,pthread_self(), inet_ntoa(client.sin_addr),htons(client.sin_port), tv.tv_sec,tv.tv_usec); int i = 0; pthread_mutex_lock(&amp;mutex); for( i = 0; i &lt; 5; i++ ) &#123; if( pthread_self() == childTid[i] ) &#123; cnt[i]++; break; &#125; &#125; printf( &quot;%ld, %ld, %ld, %ld, %ld \\n&quot;, cnt[0], cnt[1], cnt[2], cnt[3], cnt[4] ); pthread_mutex_unlock(&amp;mutex); close(connectfd); &#125; return;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// client.c:#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netdb.h&gt; /* netdb is necessary for struct hostent */#define PORT 4321 /* server port */#define MAXDATASIZE 100int main(int argc, char *argv[])&#123; int sockfd, num; /* files descriptors */ char buf[MAXDATASIZE]; /* buf will store received text */ struct hostent *he; /* structure that will get information about remote host */ struct sockaddr_in server; if (argc != 2) &#123; printf(&quot;Usage: %s &lt;IP Address&gt;\\n&quot;,argv[0]); exit(1); &#125; if((he=gethostbyname(argv[1]))==NULL) &#123; printf(&quot;gethostbyname() error\\n&quot;); exit(1); &#125; if((sockfd=socket(AF_INET,SOCK_STREAM, 0))==-1) &#123; printf(&quot;socket() error\\n&quot;); exit(1); &#125; bzero(&amp;server,sizeof(server)); server.sin_family = AF_INET; server.sin_port = htons(PORT); server.sin_addr = *((struct in_addr *)he-&gt;h_addr); if(connect(sockfd, (struct sockaddr *)&amp;server, sizeof(server))==-1) &#123; printf(&quot;connect() error\\n&quot;); exit(1); &#125; close(sockfd); return 0;&#125; 1234567891011121314151617181920212223//test.c:#include &lt;stdio.h&gt;int main()&#123; int ret = 0; long long cnt = 0; while(1) &#123; system(&quot;./client 127.0.0.1&quot;); cnt++; if( 10000 == cnt ) &#123; break; &#125; &#125; return ret;&#125;//运行结果：./test./testpthread-id=870520576,You got a connection from client&#x27;s ip 127.0.0.1, port 36335 at time 1480235067.9808923995, 4007, 4006, 3995, 3997 结论只会唤醒一个线程，且每个线程被唤醒的次数基本相等，多个线程监听同一个fd基本没问题","raw":null,"content":null,"categories":null,"tags":[{"name":"multi pthread","slug":"multi-pthread","permalink":"http://damotiansheng.github.io/tags/multi-pthread/"}]},{"title":"fastdfs配置文件解析模块","slug":null,"date":"2016-11-06T11:11:20.000Z","updated":null,"comments":null,"path":"fastdfs/2016-11-06/fastdfs配置文件解析模块.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"加载配置文件解析配置文件有： storage.conf,tracker.conf,mod_fastdfs.conf,http.conf等，配置文件中还可以用#include包含其他配置文件，如#include http.conf。该配置文件解析模块就是读取这些配置文件，然后解析保存，方便得到其中的值。如：result&#x3D;iniLoadFromFileEx(filename, &amp;iniContext, true)pBasePath &#x3D; iniGetStrValue(NULL, “base_path”, &amp;iniContext); &#x2F;&#x2F;该函数就可以得到配置文件中base_path的值 相关参考：http://slucx.blog.chinaunix.net/uid-29504236-id-4369694.html 1. 相关数据结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465typedef struct&#123; IniSection global; //保存全局key,value对 HashArray sections; //key is session name, and value is IniSection,这里hash数组用来保存[group1]下隶属于group1的&lt;key,value&gt;对 IniSection *current_section; //for load from ini file，当前正在处理的IniSection char config_path[MAX_PATH_SIZE]; //save the config filepath, such as conf file is /etc/data/xxx.conf, config_path is /etc/data bool ignore_annotation; // 是否忽略注解，看代码时可以略过不看&#125; IniContext;typedef struct&#123; IniItem *items; int count; //item count int alloc_count;&#125; IniSection;typedef struct&#123; char name[FAST_INI_ITEM_NAME_LEN + 1]; char value[FAST_INI_ITEM_VALUE_LEN + 1];&#125; IniItem;typedef struct tagHashArray&#123; HashData **buckets; HashFunc hash_func; // default is Time33Hash func int item_count; // is all the item saved in buckets unsigned int *capacity; // pointer to prime global aarray, see hash_init_ex func double load_factor; int64_t max_bytes; // means the max size of space which can be used in hashArray int64_t bytes_used; // means the size of have been used, is the *capacity * sizeof(HashData *)，为已经使用的字节数 bool is_malloc_capacity; // is_malloc_value is true: means the buffer of value is allocated in outer space, rather than beening allocated in the end of the key buffer bool is_malloc_value; // it means hashArray whether malloc space for value or not, default is false unsigned int lock_count; pthread_mutex_t *locks;&#125; HashArray;typedef struct tagHashData&#123; int key_len; int value_len; int malloc_value_size;#ifdef HASH_STORE_HASH_CODE unsigned int hash_code;#endif char *value; struct tagHashData *next; char key[0];&#125; HashData; // 元素typedef int (*HashFunc) (const void *key, const int key_len);static CDCPair g_dynamic_contents[_MAX_DYNAMIC_CONTENTS] = &#123;&#123;false, NULL, &#123;0, 0, NULL&#125;&#125;&#125;; //用一个全局数组来保存已经解析过的文件typedef struct &#123; bool used; IniContext *context; DynamicContents dynamicContents;&#125; CDCPair; 其中的sections是一个hash数组，用到的hash函数默认为Time33Hash函数进行hash插入时，具体见hash_insert函数：hash_code &#x3D; pHash-&gt;hash_func(key, key_len);ppBucket &#x3D; pHash-&gt;buckets + (hash_code % (*pHash-&gt;capacity)); key是section_name, key_len是section_len，而section_name, section_len为”[]”包围的字符串，见iniDoLoadItemsFromBuffer函数如： [group1], section_name, section_len分别为group1和6mod_fastdfs.conf文件中有： 123456#[group1]#group_name=group1#storage_server_port=23000#store_path_count=2#store_path0=/home/yuqing/fastdfs#store_path1=/home/yuqing/fastdfs1 这里的group1就为section_name, section_len是6，此时current_section会指向一个新分配的IniSection，接着会将读取得到的group_name等&lt;key,value&gt;对插入到current_section中去，然后插入到hash数组中去。配置文件模块其实就是读取配置文件，然后初始化IniContext结构体。 2. 下面讲解各个函数1234调用路径如下：iniLoadFromFile -&gt; iniLoadFromFileEx -&gt; iniInitContext、iniDoLoadFromFile、iniSortItems、iniFreeContextiniInitContext -&gt; hash_inithash_init-&gt;hash_init_ex-&gt;_hash_alloc_buckets 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097209820992100210121022103210421052106210721082109211021112112211321142115211621172118211921202121212221232124212521262127212821292130213121322133213421352136213721382139214021412142214321442145214621472148214921502151215221532154215521562157215821592160216121622163216421652166216721682169217021712172217321742175217621772178217921802181218221832184218521862187218821892190219121922193219421952196219721982199220022012202220322042205220622072208220922102211221222132214221522162217221822192220222122222223222422252226222722282229223022312232223322342235223622372238223922402241224222432244224522462247224822492250225122522253225422552256225722582259226022612262226322642265226622672268226922702271227222732274227522762277227822792280228122822283228422852286228722882289229022912292229322942295229622972298229923002301230223032304230523062307230823092310231123122313231423152316231723182319232023212322232323242325232623272328232923302331233223332334233523362337233823392340234123422343234423452346234723482349235023512352235323542355235623572358235923602361236223632364236523662367236823692370237123722373237423752376237723782379238023812382238323842385238623872388238923902391239223932394239523962397239823992400240124022403240424052406240724082409241024112412241324142415241624172418241924202421242224232424242524262427242824292430243124322433243424352436243724382439244024412442244324442445244624472448244924502451245224532454245524562457245824592460246124622463246424652466246724682469247024712472247324742475247624772478247924802481248224832484248524862487248824892490249124922493249424952496249724982499250025012502250325042505250625072508250925102511251225132514251525162517251825192520252125222523252425252526252725282529253025312532253325342535253625372538253925402541254225432544254525462547254825492550255125522553255425552556255725582559256025612562256325642565256625672568256925702571257225732574257525762577257825792580258125822583258425852586258725882589259025912592259325942595259625972598259926002601260226032604260526062607260826092610261126122613261426152616261726182619262026212622262326242625262626272628262926302631263226332634263526362637263826392640264126422643264426452646264726482649265026512652265326542655265626572658265926602661266226632664266526662667266826692670267126722673267426752676267726782679268026812682268326842685268626872688268926902691269226932694269526962697269826992700int iniLoadFromFile(const char *szFilename, IniContext *pContext)&#123; return iniLoadFromFileEx(szFilename, pContext, false);&#125;int iniLoadFromFileEx(const char *szFilename, IniContext *pContext, bool ignore_annotation) // annotation is 注释, such as symbol = /* */&#123; int result; int len; char *pLast; char full_filename[MAX_PATH_SIZE]; //保存完整文件名路径 if ((result=iniInitContext(pContext)) != 0) &#123; return result; &#125; pContext-&gt;ignore_annotation = ignore_annotation; //default is true if (strncasecmp(szFilename, &quot;http://&quot;, 7) == 0) // szFilename可以为类似： http://www.abc.com/sdfs/xxx.conf &#123; *pContext-&gt;config_path = &#x27;\\0&#x27;; snprintf(full_filename, sizeof(full_filename),&quot;%s&quot;,szFilename); &#125; else &#123; if (*szFilename == &#x27;/&#x27;) // szFilename is the absolute path &#123; pLast = strrchr(szFilename, &#x27;/&#x27;); //从后面开始查找第一个字符&#x27;/&#x27; len = pLast - szFilename; if (len &gt;= sizeof(pContext-&gt;config_path)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot;\\ &quot;the path of the config file: %s is &quot; \\ &quot;too long!&quot;, __LINE__, szFilename); return ENOSPC; &#125; memcpy(pContext-&gt;config_path, szFilename, len); *(pContext-&gt;config_path + len) = &#x27;\\0&#x27;; snprintf(full_filename, sizeof(full_filename), \\ &quot;%s&quot;, szFilename); &#125; else // 表明是从当前路径下的文件名，szFilename is the conf file name or is current_dir/xxx1/xxx2/xxx.conf &#123; memset(pContext-&gt;config_path, 0, \\ sizeof(pContext-&gt;config_path)); if (getcwd(pContext-&gt;config_path, sizeof( \\ pContext-&gt;config_path)) == NULL) //getcwd函数为得到当前目录 &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;getcwd fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, \\ __LINE__, errno, STRERROR(errno)); return errno != 0 ? errno : EPERM; &#125; len = strlen(pContext-&gt;config_path); if (len &gt; 0 &amp;&amp; pContext-&gt;config_path[len - 1] == &#x27;/&#x27;) &#123; len--; *(pContext-&gt;config_path + len) = &#x27;\\0&#x27;; &#125; // make sure the last char is not &#x27;/&#x27; snprintf(full_filename, sizeof(full_filename), \\ &quot;%s/%s&quot;, pContext-&gt;config_path, szFilename); pLast = strrchr(szFilename, &#x27;/&#x27;); if (pLast != NULL) // such as szFilename is &quot;data/xxx.conf&quot; &#123; int tail_len; tail_len = pLast - szFilename; if (len + 1 + tail_len &gt;= sizeof( \\ pContext-&gt;config_path)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot;\\ &quot;the path of the config &quot; \\ &quot;file: %s is too long!&quot;, \\ __LINE__, szFilename); return ENOSPC; &#125; *(pContext-&gt;config_path + len++) = &#x27;/&#x27;; memcpy(pContext-&gt;config_path + len, \\ szFilename, tail_len); len += tail_len; *(pContext-&gt;config_path + len) = &#x27;\\0&#x27;; &#125; &#125; &#125; // now full_filename is the absolute path of conf file, pContext-&gt;config_path // is the conf file directory result = iniDoLoadFromFile(full_filename, pContext); if (result == 0) &#123; iniSortItems(pContext); &#125; else &#123; iniFreeContext(pContext); &#125; return result;&#125;// init the member of IniContext, such as init the hash member:pContext-&gt;sectionsstatic int iniInitContext(IniContext *pContext)&#123; int result; memset(pContext, 0, sizeof(IniContext)); pContext-&gt;current_section = &amp;pContext-&gt;global; //指向global,用于保存全局key,value对 if ((result=hash_init(&amp;pContext-&gt;sections, Time33Hash, 32, 0.75)) != 0) //hash数组初始化，Time33Hash为hash函数，32为容量，0.75为负载因子 &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;hash_init fail, errno: %d, error info: %s&quot;, \\ __LINE__, result, STRERROR(result)); &#125; return result;&#125;hash函数如下：#define TIME33_HASH_FUNC(init_value) \\ int nHash; \\ unsigned char *pKey; \\ unsigned char *pEnd; \\ \\ nHash = init_value; \\ pEnd = (unsigned char *)key + key_len; \\ for (pKey = (unsigned char *)key; pKey != pEnd; pKey++) \\ &#123; \\ nHash += (nHash &lt;&lt; 5) + (*pKey); \\ &#125; \\ \\ return nHash; \\// get a int value according to the key valueint Time33Hash(const void *key, const int key_len)&#123; TIME33_HASH_FUNC(0)&#125;#define hash_init(pHash, hash_func, capacity, load_factor) \\ hash_init_ex(pHash, hash_func, capacity, load_factor, 0, false)// 参数依次为：要初始化的hash数组，hash函数，容量，负载因子（当前保存的项数/capacity）,hash数组能用的最大字节数，保存value的空间是否已经在外部被分配了int hash_init_ex(HashArray *pHash, HashFunc hash_func, \\ const unsigned int capacity, const double load_factor, \\ const int64_t max_bytes, const bool bMallocValue)&#123; unsigned int *pprime; unsigned int *prime_end; int result; memset(pHash, 0, sizeof(HashArray)); prime_end = prime_array + PRIME_ARRAY_SIZE; // 素数数组 for (pprime = prime_array; pprime!=prime_end; pprime++) &#123; if ( *pprime &gt; capacity ) //找到第一个大于容量的素数 &#123; pHash-&gt;capacity = pprime; break; &#125; &#125; if (pHash-&gt;capacity == NULL) &#123; return EINVAL; &#125; if ((result=_hash_alloc_buckets(pHash, 0)) != 0) //分配桶 &#123; return result; &#125; pHash-&gt;hash_func = hash_func; pHash-&gt;max_bytes = max_bytes; //hash数组能够使用的最大字节数 pHash-&gt;is_malloc_value = bMallocValue; // default is false，保存key,value中的value数据时的空间是否已经在外部被分配 // load_factor default is 0.75 if (load_factor &gt;= 0.00 &amp;&amp; load_factor &lt;= 1.00) &#123; pHash-&gt;load_factor = load_factor; &#125; else &#123; pHash-&gt;load_factor = 0.50; &#125; return 0;&#125;// 素数数组static unsigned int prime_array[] = &#123; 1, /* 0 */ 3, /* 1 */ 17, /* 2 */ 37, /* 3 */ 79, /* 4 */ 163, /* 5 */ 331, /* 6 */ 673, /* 7 */ 1361, /* 8 */ 2729, /* 9 */ 5471, /* 10 */ 10949, /* 11 */ 21911, /* 12 */ 43853, /* 13 */ 87719, /* 14 */ 175447, /* 15 */ 350899, /* 16 */ 701819, /* 17 */ 1403641, /* 18 */ 2807303, /* 19 */ 5614657, /* 20 */ 11229331, /* 21 */ 22458671, /* 22 */ 44917381, /* 23 */ 89834777, /* 24 */ 179669557, /* 25 */ 359339171, /* 26 */ 718678369, /* 27 */ 1437356741, /* 28 */ 2147483647 /* 29 (largest signed int prime) */&#125;;#define PRIME_ARRAY_SIZE 30// allocate the space of hash arraystatic int _hash_alloc_buckets(HashArray *pHash, const unsigned int old_capacity)&#123; size_t bytes; bytes = sizeof(HashData *) * (*pHash-&gt;capacity); if (pHash-&gt;max_bytes &gt; 0 &amp;&amp; pHash-&gt;bytes_used+bytes &gt; pHash-&gt;max_bytes) &#123; return ENOSPC; // no more memory in device &#125; pHash-&gt;buckets = (HashData **)malloc(bytes); if (pHash-&gt;buckets == NULL) &#123; return ENOMEM; &#125; memset(pHash-&gt;buckets, 0, bytes); // sizeof(HashData *) * old_capacity为旧数组的大小 pHash-&gt;bytes_used += bytes - sizeof(HashData *) * old_capacity; //bytes为新大小，减去旧数组大小则为新增大小 return 0;&#125;static int iniDoLoadFromFile(const char *szFilename, \\ IniContext *pContext)&#123; char *content; int result; int http_status; int content_len; int64_t file_size; char error_info[512]; if (strncasecmp(szFilename, &quot;http://&quot;, 7) == 0) // 是否为http://xxx.xx.xx/xx1/xx.conf形式 &#123; // szFilename: http://xx1.xx2.xx3/haha/dir/xxx.conf if ((result=get_url_content(szFilename, 10, 60, &amp;http_status, \\ &amp;content, &amp;content_len, error_info)) != 0) //get_url_content函数发送http请求获得文件内容 &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;get_url_content fail, &quot; \\ &quot;url: %s, error info: %s&quot;, \\ __LINE__, szFilename, error_info); return result; &#125; if (http_status != 200) // means http response status is not correct &#123; free(content); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;HTTP status code: %d != 200, url: %s&quot;, \\ __LINE__, http_status, szFilename); return EINVAL; &#125; &#125; else &#123; if ((result=getFileContent(szFilename, &amp;content, \\ &amp;file_size)) != 0) &#123; return result; &#125; &#125; result = iniLoadItemsFromBuffer(content, pContext); free(content); return result;&#125;int get_url_content(const char *url, const int connect_timeout, \\ const int network_timeout, int *http_status, \\ char **content, int *content_len, char *error_info)&#123; *content = NULL; return get_url_content_ex(url, strlen(url), connect_timeout, network_timeout, http_status, content, content_len, error_info);&#125;/*get the content of url, the func will send http request and recv http response// connect_timeout is 10 default// network_timeout is 60 defaulthttp_status用于保存http响应报文的状态，如http 1.1 200 ok中的200content和content_len用于保存内容和长度error_info用于保存错误信息*/int get_url_content_ex(const char *url, const int url_len, const int connect_timeout, const int network_timeout, int *http_status, char **content, int *content_len, char *error_info)&#123; char domain_name[256]; char ip_addr[IP_ADDRESS_SIZE]; char out_buff[4096]; int domain_len; int out_len; int alloc_size; int recv_bytes; int result; int sock; int port; bool bNeedAlloc; const char *pDomain; const char *pContent; const char *pURI; char *pPort; char *pSpace; *http_status = 0; if (*content == NULL) &#123; bNeedAlloc = true; alloc_size = 64 * 1024; &#125; else &#123; bNeedAlloc = false; alloc_size = *content_len - 1; &#125; *content_len = 0; if (url_len &gt; sizeof(out_buff) - 128) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;url too long, url length: %d &gt; %d&quot;, __LINE__, url_len, (int)(sizeof(out_buff) - 128)); return ENAMETOOLONG; &#125; if (url_len &lt;= 7 || strncasecmp(url, &quot;http://&quot;, 7) != 0) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;invalid url.&quot;, __LINE__); return EINVAL; &#125; pDomain = url + 7; pURI = strchr(pDomain, &#x27;/&#x27;); if (pURI == NULL) &#123; domain_len = url_len - 7; pURI = &quot;/&quot;; &#125; else &#123; domain_len = pURI - pDomain; &#125; if (domain_len &gt;= sizeof(domain_name)) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;domain is too large, exceed %d.&quot;, \\ __LINE__, (int)sizeof(domain_name)); return EINVAL; &#125; memcpy(domain_name, pDomain, domain_len); *(domain_name + domain_len) = &#x27;\\0&#x27;; pPort = strchr(domain_name, &#x27;:&#x27;); if (pPort == NULL) &#123; port = 80; &#125; else &#123; *pPort = &#x27;\\0&#x27;; port = atoi(pPort + 1); &#125; if (getIpaddrByName(domain_name, ip_addr, \\ sizeof(ip_addr)) == INADDR_NONE) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;resolve domain \\&quot;%s\\&quot; fail.&quot;, \\ __LINE__, domain_name); return EINVAL; &#125; sock = socket(AF_INET, SOCK_STREAM, 0); if(sock &lt; 0) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;socket create failed, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, \\ errno, STRERROR(errno)); return errno != 0 ? errno : EPERM; &#125; if ((result=connectserverbyip_nb_auto(sock, ip_addr, port, \\ connect_timeout)) != 0) &#123; close(sock); sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;connect to %s:%d fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, domain_name, \\ port, result, STRERROR(result)); return result; &#125; out_len = snprintf(out_buff, sizeof(out_buff), \\ &quot;GET %s HTTP/1.0\\r\\n&quot; \\ &quot;Host: %s:%d\\r\\n&quot; \\ &quot;Connection: close\\r\\n&quot; \\ &quot;\\r\\n&quot;, pURI, domain_name, port); // we have Connection: close means: the peer will shutdown the socket when it has finished sending data // send http request if ((result=tcpsenddata(sock, out_buff, out_len, network_timeout)) != 0) &#123; close(sock); sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;send data to %s:%d fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, domain_name, \\ port, result, STRERROR(result)); return result; &#125; if (bNeedAlloc) &#123; *content = (char *)malloc(alloc_size + 1); if (*content == NULL) &#123; close(sock); result = errno != 0 ? errno : ENOMEM; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;malloc %d bytes fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, alloc_size + 1, \\ result, STRERROR(result)); return result; &#125; &#125; do &#123; recv_bytes = alloc_size - *content_len; // recv_bytes: left space to recv data if (recv_bytes &lt;= 0) &#123; if (bNeedAlloc) &#123; alloc_size *= 2; *content = (char *)realloc(*content, alloc_size + 1); if (*content == NULL) &#123; *content_len = 0; close(sock); result = errno != 0 ? errno : ENOMEM; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;realloc %d bytes fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, \\ alloc_size + 1, \\ result, STRERROR(result)); return result; &#125; recv_bytes = alloc_size - *content_len; &#125; else &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;buffer size: %d is too small&quot;, \\ __LINE__, alloc_size); return ENOSPC; &#125; &#125; result = tcprecvdata_ex(sock, *content + *content_len, \\ recv_bytes, network_timeout, &amp;recv_bytes); *content_len += recv_bytes; &#125; while (result == 0); do &#123; if (result == ENOTCONN) // means the peer has shutdowned the socket &#123; result = 0; // success value &#125; else &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;recv data from %s:%d fail, errno: %d, &quot; \\ &quot;error info: %s&quot;, __LINE__, domain_name, \\ port, result, STRERROR(result)); break; &#125; *(*content + *content_len) = &#x27;\\0&#x27;; pContent = strstr(*content, &quot;\\r\\n\\r\\n&quot;); if (pContent == NULL) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;response data from %s:%d is invalid&quot;, \\ __LINE__, domain_name, port); result = EINVAL; break; &#125; pContent += 4; // pointer to the next line pSpace = strchr(*content, &#x27; &#x27;); if (pSpace == NULL || pSpace &gt;= pContent) &#123; sprintf(error_info, &quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;response data from %s:%d is invalid&quot;, \\ __LINE__, domain_name, port); result = EINVAL; break; &#125; *http_status = atoi(pSpace + 1); // http response status: such as http/1.1 200 ok *content_len -= pContent - *content; // minus the length of status line: http/1.1 200 ok memcpy(*content, pContent, *content_len); // remove the status line *(*content + *content_len) = &#x27;\\0&#x27;; *error_info = &#x27;\\0&#x27;; &#125; while (0); close(sock); if (result != 0 &amp;&amp; bNeedAlloc) // result !=0: means error occured &#123; free(*content); *content = NULL; *content_len = 0; &#125; return result;&#125;// return the string ip addr by ip name(maybe is digital ip addr or domain addr)in_addr_t getIpaddrByName(const char *name, char *buff, const int bufferSize)&#123; struct in_addr ip_addr; struct hostent *ent; in_addr_t **addr_list; if ((*name &gt;= &#x27;0&#x27; &amp;&amp; *name &lt;= &#x27;9&#x27;) &amp;&amp; // name is the digital ip address inet_pton(AF_INET, name, &amp;ip_addr) == 1) // success &#123; if (buff != NULL) &#123; snprintf(buff, bufferSize, &quot;%s&quot;, name); &#125; return ip_addr.s_addr; &#125; ent = gethostbyname(name); if (ent == NULL) &#123; return INADDR_NONE; &#125; addr_list = (in_addr_t **)ent-&gt;h_addr_list; if (addr_list[0] == NULL) &#123; return INADDR_NONE; &#125; memset(&amp;ip_addr, 0, sizeof(ip_addr)); ip_addr.s_addr = *(addr_list[0]); if (buff != NULL) &#123; if (inet_ntop(AF_INET, &amp;ip_addr, buff, bufferSize) == NULL) &#123; *buff = &#x27;\\0&#x27;; &#125; &#125; return ip_addr.s_addr;&#125;/** connect to server by non-block mode, auto detect socket block mode * parameters: * sock: the socket, can be block mode * server_ip: ip address of the server * server_port: port of the server * timeout: connect timeout in seconds * return: error no, 0 success, != 0 fail*/#define connectserverbyip_nb_auto(sock, server_ip, server_port, timeout) \\ connectserverbyip_nb_ex(sock, server_ip, server_port, timeout, true)// connect the server by ip , return 0 stands for connect succeedint connectserverbyip_nb_ex(int sock, const char *server_ip, \\ const short server_port, const int timeout, \\ const bool auto_detect)&#123; int result; int flags; bool needRestore; socklen_t len;#ifdef USE_SELECT fd_set rset; fd_set wset; struct timeval tval;#else struct pollfd pollfds;#endif struct sockaddr_in addr; struct sockaddr_in6 addr6; void *dest; int size; memset(&amp;addr, 0, sizeof(struct sockaddr_in)); memset(&amp;addr6, 0, sizeof(struct sockaddr_in6)); if ((result=setsockaddrbyip(server_ip, server_port, &amp;addr, &amp;addr6, &amp;dest, &amp;size)) != 0) &#123; return result; &#125; if (auto_detect) &#123; flags = fcntl(sock, F_GETFL, 0); if (flags &lt; 0) &#123; return errno != 0 ? errno : EACCES; &#125; if ((flags &amp; O_NONBLOCK) == 0) &#123; if (fcntl(sock, F_SETFL, flags | O_NONBLOCK) &lt; 0) &#123; return errno != 0 ? errno : EACCES; &#125; needRestore = true; &#125; else &#123; needRestore = false; &#125; &#125; else &#123; needRestore = false; flags = 0; &#125; do &#123; if (connect(sock, (const struct sockaddr*)dest, size) &lt; 0) &#123; result = errno != 0 ? errno : EINPROGRESS; if (result != EINPROGRESS) &#123; break; &#125; &#125; else // connect return 0: success, -1: failure &#123; result = 0; break; &#125; // after call connect, we call select or poll to get error if error occurs#ifdef USE_SELECT FD_ZERO(&amp;rset); FD_ZERO(&amp;wset); FD_SET(sock, &amp;rset); FD_SET(sock, &amp;wset); tval.tv_sec = timeout; tval.tv_usec = 0; result = select(sock+1, &amp;rset, &amp;wset, NULL, \\ timeout &gt; 0 ? &amp;tval : NULL);#else pollfds.fd = sock; pollfds.events = POLLIN | POLLOUT; result = poll(&amp;pollfds, 1, 1000 * timeout);#endif if (result == 0) &#123; result = ETIMEDOUT; break; &#125; else if (result &lt; 0) &#123; result = errno != 0 ? errno : EINTR; break; &#125; // means return value &gt; 0 len = sizeof(result); // getsockopt: 0: success, -1:failure if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &amp;result, &amp;len) &lt; 0) &#123; result = errno != 0 ? errno : EACCES; // means failure break; &#125; &#125; while (0); if (needRestore) &#123; fcntl(sock, F_SETFL, flags); &#125; return result;&#125;/*get the content of filename, which is saved to *buff, the size of filename is saved to file_size*/int getFileContent(const char *filename, char **buff, int64_t *file_size)&#123; int fd; if (!isFile(filename)) &#123; *buff = NULL; *file_size = 0; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;%s is not a regular file&quot;, __LINE__, filename); return EINVAL; &#125; fd = open(filename, O_RDONLY); if (fd &lt; 0) &#123; *buff = NULL; *file_size = 0; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;open file %s fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, __LINE__, \\ filename, errno, STRERROR(errno)); return errno != 0 ? errno : ENOENT; &#125; if ((*file_size=lseek(fd, 0, SEEK_END)) &lt; 0) &#123; *buff = NULL; *file_size = 0; close(fd); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;lseek file %s fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, __LINE__, \\ filename, errno, STRERROR(errno)); return errno != 0 ? errno : EIO; &#125; *buff = (char *)malloc(*file_size + 1); if (*buff == NULL) &#123; *file_size = 0; close(fd); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;malloc %d bytes fail&quot;, __LINE__, \\ (int)(*file_size + 1)); return errno != 0 ? errno : ENOMEM; &#125; if (lseek(fd, 0, SEEK_SET) &lt; 0) &#123; *buff = NULL; *file_size = 0; close(fd); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;lseek file %s fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, __LINE__, \\ filename, errno, STRERROR(errno)); return errno != 0 ? errno : EIO; &#125; if (read(fd, *buff, *file_size) != *file_size) &#123; free(*buff); *buff = NULL; *file_size = 0; close(fd); logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;read from file %s fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, __LINE__, \\ filename, errno, STRERROR(errno)); return errno != 0 ? errno : EIO; &#125; (*buff)[*file_size] = &#x27;\\0&#x27;; close(fd); return 0;&#125;static int iniLoadItemsFromBuffer(char *content, IniContext *pContext)&#123; char *pContent; char *new_content; int content_len; int new_content_len; new_content = content; new_content_len = strlen(content); do &#123; pContent = new_content; // after get rid of first #@if, process left #@if content_len = new_content_len; if ((new_content=iniProccessIf(pContent, content_len, pContext, &amp;new_content_len)) == NULL) &#123; return ENOMEM; &#125; &#125; while (new_content != pContent); do &#123; pContent = new_content; content_len = new_content_len; if ((new_content=iniProccessFor(pContent, content_len, pContext, &amp;new_content_len)) == NULL) &#123; return ENOMEM; &#125; &#125; while (new_content != pContent); // loop processing return iniDoLoadItemsFromBuffer(new_content, pContext); &#125;/*function: reslove the content, and get rid of #@if and #@endif, save to new bufferreturnd by iniProcessIf, such as:content is:#@if xxx...abc#@endif...defnew buffer is: ...abc...defreturned by iniProcessIf该函数看不懂感觉可以略过不看*/static char *iniProccessIf(char *content, const int content_len, IniContext *pContext, int *new_content_len)&#123; char *pStart; char *pEnd; char *pCondition; char *pElse; char *pIfPart; char *pElsePart; int conditionLen; int ifPartLen; int elsePartLen; int copyLen; char *newContent; char *pDest; *new_content_len = content_len; pStart = strstr(content, _PREPROCESS_TAG_STR_IF); if (pStart == NULL) &#123; return content; &#125; pCondition = pStart + _PREPROCESS_TAG_LEN_IF; pIfPart = strchr(pCondition, &#x27;\\n&#x27;); if (pIfPart == NULL) &#123; return content; &#125; conditionLen = pIfPart - pCondition; pEnd = strstr(pIfPart, _PREPROCESS_TAG_STR_ENDIF); if (pEnd == NULL) &#123; return content; &#125; pElse = strstr(pIfPart, _PREPROCESS_TAG_STR_ELSE); if (pElse == NULL || pElse &gt; pEnd) &#123; ifPartLen = pEnd - pIfPart; pElsePart = NULL; elsePartLen = 0; &#125; else &#123; ifPartLen = pElse - pIfPart; pElsePart = strchr(pElse + _PREPROCESS_TAG_LEN_ELSE, &#x27;\\n&#x27;); if (pElsePart == NULL) &#123; return content; &#125; elsePartLen = pEnd - pElsePart; &#125; newContent = iniAllocContent(pContext, content_len); // newContent is the buffer address if (newContent == NULL) &#123; return NULL; &#125; pDest = newContent; copyLen = pStart - content; if (copyLen &gt; 0) &#123; memcpy(pDest, content, copyLen); pDest += copyLen; &#125; if (iniCalcCondition(pCondition, conditionLen)) &#123; if (ifPartLen &gt; 0) &#123; memcpy(pDest, pIfPart, ifPartLen); pDest += ifPartLen; &#125; &#125; else &#123; if (elsePartLen &gt; 0) &#123; memcpy(pDest, pElsePart, elsePartLen); pDest += elsePartLen; &#125; &#125; copyLen = (content + content_len) - (pEnd + _PREPROCESS_TAG_LEN_ENDIF); if (copyLen &gt; 0) &#123; memcpy(pDest, pEnd + _PREPROCESS_TAG_LEN_ENDIF, copyLen); pDest += copyLen; &#125; *pDest = &#x27;\\0&#x27;; *new_content_len = pDest - newContent; return newContent;&#125;/* process the for block: #@for ... #@endforget rid of the #@endfor, #@for, and expand the for loop which replace &#123;$i&#125; with the real valueand saved to new buffer returned by iniProcessFor该函数与上一个函数类似*/static char *iniProccessFor(char *content, const int content_len, IniContext *pContext, int *new_content_len)&#123; char *pStart; char *pEnd; char *pForRange; char *pForBlock; char *id; char tag[80]; char value[16]; int idLen; int rangeLen; int forBlockLen; int start; int end; int step; int count; int i; int copyLen; int tagLen; int valueLen; char *newContent; char *pDest; *new_content_len = content_len; pStart = strstr(content, _PREPROCESS_TAG_STR_FOR); if (pStart == NULL) &#123; return content; &#125; pForRange = pStart + _PREPROCESS_TAG_LEN_FOR; // for condition begin pForBlock = strchr(pForRange, &#x27;\\n&#x27;); // for block begin if (pForBlock == NULL) &#123; return content; &#125; rangeLen = pForBlock - pForRange; pEnd = strstr(pForBlock, _PREPROCESS_TAG_STR_ENDFOR); if (pEnd == NULL) &#123; return content; &#125; forBlockLen = pEnd - pForBlock; // for block len if (iniParseForRange(pForRange, rangeLen, &amp;id, &amp;idLen, &amp;start, &amp;end, &amp;step) != 0) &#123; return NULL; &#125; if (step == 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid step: %d for range: %.*s&quot;, __LINE__, step, rangeLen, pForRange); return NULL; &#125; count = (end - start) / step; // how many steps if (count &lt; 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid step: %d for range: %.*s&quot;, __LINE__, step, rangeLen, pForRange); return NULL; &#125; newContent = iniAllocContent(pContext, content_len + (forBlockLen + 16) * count); if (newContent == NULL) &#123; return NULL; &#125; pDest = newContent; // newContent is the buffer addr to stored for block content copyLen = pStart - content; if (copyLen &gt; 0) &#123; memcpy(pDest, content, copyLen); pDest += copyLen; &#125; // id=&quot;i&quot;, idLen=1, tag will be &quot;&#123;$i&#125;&quot;, tagLen will be 4 = strlen(&quot;&#123;$i&#125;&quot;) tagLen = sprintf(tag, &quot;&#123;$%.*s&#125;&quot;, idLen, id); // tagLen is the variable length for (i=start; i&lt;=end; i+=step) &#123; char *p; char *pRemain; int remainLen; valueLen = sprintf(value, &quot;%d&quot;, i); pRemain = pForBlock; remainLen = forBlockLen; while (remainLen &gt;= tagLen) &#123; p = (char *)memmem(pRemain, remainLen, tag, tagLen); if (p == NULL) &#123; memcpy(pDest, pRemain, remainLen); pDest += remainLen; break; &#125; copyLen = p - pRemain; if (copyLen &gt; 0) &#123; memcpy(pDest, pRemain, copyLen); pDest += copyLen; &#125; memcpy(pDest, value, valueLen); pDest += valueLen; pRemain = p + tagLen; remainLen -= copyLen + tagLen; &#125; &#125; copyLen = (content + content_len) - (pEnd + _PREPROCESS_TAG_LEN_ENDFOR); if (copyLen &gt; 0) &#123; memcpy(pDest, pEnd + _PREPROCESS_TAG_LEN_ENDFOR, copyLen); pDest += copyLen; &#125; *pDest = &#x27;\\0&#x27;; *new_content_len = pDest - newContent; return newContent;&#125;//alloc space for the length of content_len, return the buffer addrstatic char *iniAllocContent(IniContext *pContext, const int content_len)&#123; char *buff; DynamicContents *pDynamicContents; pDynamicContents = iniAllocDynamicContent(pContext); if (pDynamicContents == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;malloc dynamic contents fail&quot;, __LINE__); return NULL; &#125; // default: pDynamicContents-&gt;count = 0, pDynamicContents-&gt;alloc_count=0 if (pDynamicContents-&gt;count &gt;= pDynamicContents-&gt;alloc_count) &#123; int alloc_count; int bytes; char **contents; if (pDynamicContents-&gt;alloc_count == 0) &#123; alloc_count = 8; &#125; else &#123; alloc_count = pDynamicContents-&gt;alloc_count * 2; &#125; bytes = sizeof(char *) * alloc_count; contents = (char **)malloc(bytes); if (contents == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;malloc %d bytes fail&quot;, __LINE__, bytes); return NULL; &#125; memset(contents, 0, bytes); if (pDynamicContents-&gt;count &gt; 0) &#123; memcpy(contents, pDynamicContents-&gt;contents, sizeof(char *) * pDynamicContents-&gt;count); free(pDynamicContents-&gt;contents); &#125; pDynamicContents-&gt;contents = contents; pDynamicContents-&gt;alloc_count = alloc_count; &#125; buff = malloc(content_len); if (buff == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;malloc %d bytes fail&quot;, __LINE__, content_len); return NULL; &#125; pDynamicContents-&gt;contents[pDynamicContents-&gt;count++] = buff; return buff;&#125;// find pContext in g_dynamic_contents, if find: return, or add pContext to g_dynamic_contentsstatic DynamicContents *iniAllocDynamicContent(IniContext *pContext)&#123; int i; if (g_dynamic_contents[g_dynamic_content_index].context == pContext) &#123; return &amp;g_dynamic_contents[g_dynamic_content_index].dynamicContents; &#125; if (g_dynamic_content_count &gt; 0) &#123; for (i=0; i&lt;_MAX_DYNAMIC_CONTENTS; i++) &#123; if (g_dynamic_contents[i].context == pContext) &#123; g_dynamic_content_index = i; return &amp;g_dynamic_contents[g_dynamic_content_index].dynamicContents; &#125; &#125; &#125; if (g_dynamic_content_count == _MAX_DYNAMIC_CONTENTS) &#123; return NULL; &#125; for (i=0; i&lt;_MAX_DYNAMIC_CONTENTS; i++) &#123; if (!g_dynamic_contents[i].used) &#123; g_dynamic_contents[i].used = true; g_dynamic_contents[i].context = pContext; g_dynamic_content_index = i; g_dynamic_content_count++; return &amp;g_dynamic_contents[g_dynamic_content_index].dynamicContents; &#125; &#125; return NULL;&#125;/*function: resolve the format:%&#123;LOCAL_IP&#125; in [10.0.11.89,10.0.11.99]%&#123;LOCAL_HOST&#125; in [10.0.11.89,10.0.11.99]and compare g_local_host_ip_addrs array, check every elem in g_local_host_ip_addrs iswhether exists in [10.0.11.89,10.0.11.99] or not, exists return true or return false*/static bool iniCalcCondition(char *condition, const int condition_len)&#123; /* * current only support %&#123;VARIABLE&#125; in [x,y,..] * support variables are: LOCAL_IP and LOCAL_HOST * such as: %&#123;LOCAL_IP&#125; in [10.0.11.89,10.0.11.99] **/#define _PREPROCESS_VARIABLE_TYPE_LOCAL_IP 1#define _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST 2#define _PREPROCESS_MAX_LIST_VALUE_COUNT 32 char *p; char *pEnd; char *pSquareEnd; char *values[_PREPROCESS_MAX_LIST_VALUE_COUNT]; int varType; int count; int i; pEnd = condition + condition_len; p = pEnd - 1; while (p &gt; condition &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p--; &#125; if (*p != &#x27;]&#x27;) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;expect \\&quot;]\\&quot;, condition: %.*s&quot;, __LINE__, condition_len, condition); return false; &#125; pSquareEnd = p; p = condition; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (pEnd - p &lt; 12) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;unkown condition: %.*s&quot;, __LINE__, condition_len, condition); return false; &#125; if (memcmp(p, _PREPROCESS_VARIABLE_STR_LOCAL_IP, _PREPROCESS_VARIABLE_LEN_LOCAL_IP) == 0) &#123; varType = _PREPROCESS_VARIABLE_TYPE_LOCAL_IP; p += _PREPROCESS_VARIABLE_LEN_LOCAL_IP; &#125; else if (memcmp(p, _PREPROCESS_VARIABLE_STR_LOCAL_HOST, _PREPROCESS_VARIABLE_LEN_LOCAL_HOST) == 0) &#123; varType = _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST; p += _PREPROCESS_VARIABLE_LEN_LOCAL_HOST; &#125; else &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;unkown condition: %.*s&quot;, __LINE__, condition_len, condition); return false; &#125; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (pEnd - p &lt; 4 || memcmp(p, &quot;in&quot;, 2) != 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;expect \\&quot;in\\&quot;, condition: %.*s&quot;, __LINE__, condition_len, condition); return false; &#125; p += 2; //skip in while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (*p != &#x27;[&#x27;) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;expect \\&quot;[\\&quot;, condition: %.*s&quot;, __LINE__, condition_len, condition); return false; &#125; *pSquareEnd = &#x27;\\0&#x27;; count = splitEx(p + 1, &#x27;,&#x27;, values, _PREPROCESS_MAX_LIST_VALUE_COUNT); for (i=0; i&lt;count; i++) &#123; values[i] = trim(values[i]); &#125; if (varType == _PREPROCESS_VARIABLE_TYPE_LOCAL_HOST) &#123; char host[128]; if (gethostname(host, sizeof(host)) != 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;call gethostname fail, &quot; &quot;errno: %d, error info: %s&quot;, __LINE__, errno, STRERROR(errno)); return false; &#125; return iniMatchValue(host, values, count); &#125; else &#123; const char *local_ip; local_ip = get_first_local_ip(); while (local_ip != NULL) &#123; if (iniMatchValue(local_ip, values, count)) &#123; return true; &#125; local_ip = get_next_local_ip(local_ip); &#125; &#125; return false;&#125;// find target in array: values, if find return true, else return falsestatic bool iniMatchValue(const char *target, char **values, const int count)&#123; int i; for (i=0; i&lt;count; i++) &#123; if (strcmp(target, values[i]) == 0) &#123; return true; &#125; &#125; return false;&#125;// get a integer from str ended by pEnd, nlen is the length of integerstatic char *iniGetInteger(char *str, char *pEnd, int *nlen)&#123; char *p; char *pNumber; p = str; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; pNumber = p; while (p &lt; pEnd &amp;&amp; (*p &gt;= &#x27;0&#x27; &amp;&amp; *p &lt;= &#x27;9&#x27;)) &#123; p++; &#125; *nlen = p - pNumber; return pNumber;&#125;// parse the format: #@for i from 0 to 15 step 1// *id pointer to i, idLen=1, start=0, end=15, step=1static int iniParseForRange(char *range, const int range_len, char **id, int *idLen, int *start, int *end, int *step)&#123; /** * * #@for i from 0 to 15 step 1 */ char *p; char *pEnd; char *pNumber; int nlen; pEnd = range + range_len; p = range; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (pEnd - p &lt; 10) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;unkown for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; *id = p; while (p &lt; pEnd &amp;&amp; !(*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; *idLen = p - *id; if (*idLen == 0 || *idLen &gt; 64) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; if (pEnd - p &lt; 8) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; p++; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_FROM, _PREPROCESS_TAG_LEN_FOR_FROM) == 0 &amp;&amp; (*(p+_PREPROCESS_TAG_LEN_FOR_FROM) == &#x27; &#x27; || *(p+_PREPROCESS_TAG_LEN_FOR_FROM) == &#x27;\\t&#x27;))) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; p += _PREPROCESS_TAG_LEN_FOR_FROM + 1; pNumber = iniGetInteger(p, pEnd, &amp;nlen); if (nlen == 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; *start = atoi(pNumber); //atoi meets non-numbers will stop transfer p = pNumber + nlen; if (pEnd - p &lt; 4 || !(*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; p++; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_TO, _PREPROCESS_TAG_LEN_FOR_TO) == 0 &amp;&amp; (*(p+_PREPROCESS_TAG_LEN_FOR_TO) == &#x27; &#x27; || *(p+_PREPROCESS_TAG_LEN_FOR_TO) == &#x27;\\t&#x27;))) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;unkown for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; p += _PREPROCESS_TAG_LEN_FOR_TO + 1; pNumber = iniGetInteger(p, pEnd, &amp;nlen); if (nlen == 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; *end = atoi(pNumber); p = pNumber + nlen; if (p == pEnd) // default step is set to 1 &#123; *step = 1; return 0; &#125; if (!(*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (!(memcmp(p, _PREPROCESS_TAG_STR_FOR_STEP, _PREPROCESS_TAG_LEN_FOR_STEP) == 0 &amp;&amp; (*(p+_PREPROCESS_TAG_LEN_FOR_STEP) == &#x27; &#x27; || *(p+_PREPROCESS_TAG_LEN_FOR_STEP) == &#x27;\\t&#x27;))) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;unkown for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; p += _PREPROCESS_TAG_LEN_FOR_STEP + 1; pNumber = iniGetInteger(p, pEnd, &amp;nlen); if (nlen == 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; *step = atoi(pNumber); p = pNumber + nlen; while (p &lt; pEnd &amp;&amp; (*p == &#x27; &#x27; || *p == &#x27;\\t&#x27;)) &#123; p++; &#125; if (p != pEnd) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; &quot;invalid for range: %.*s&quot;, __LINE__, range_len, range); return EINVAL; &#125; return 0;&#125;// content is the conf file content which has been preProcessed// return 0: successstatic int iniDoLoadItemsFromBuffer(char *content, IniContext *pContext)&#123; AnnotationMap *pAnnoMap; IniSection *pSection; IniItem *pItem; char *pLine; char *pLastEnd; char *pEqualChar; char *pItemName; char *pAnnoItemLine; char *pIncludeFilename; char *pItemValues[100]; char pFuncName[FAST_INI_ITEM_NAME_LEN + 1]; char full_filename[MAX_PATH_SIZE]; int i; int nLineLen; int nNameLen; int nItemCnt; int nValueLen; int result; int isAnnotation; result = 0; pAnnoItemLine = NULL; isAnnotation = 0; *pFuncName = &#x27;\\0&#x27;; pLastEnd = content - 1; pSection = pContext-&gt;current_section; pItem = pSection-&gt;items + pSection-&gt;count; while (pLastEnd != NULL) &#123; pLine = pLastEnd + 1; // pointer to the begin of a line pLastEnd = strchr(pLine, &#x27;\\n&#x27;); // pointer to the end of a line if (pLastEnd != NULL) &#123; *pLastEnd = &#x27;\\0&#x27;; &#125; if (isAnnotation &amp;&amp; pLine != pAnnoItemLine) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;the @function annotation line &quot; \\ &quot;must follow by key=value line!&quot;, __LINE__); isAnnotation = 0; &#125; if (*pLine == &#x27;#&#x27; &amp;&amp; \\ strncasecmp(pLine+1, &quot;include&quot;, 7) == 0 &amp;&amp; \\ (*(pLine+8) == &#x27; &#x27; || *(pLine+8) == &#x27;\\t&#x27;)) &#123; pIncludeFilename = strdup(pLine + 9); if (pIncludeFilename == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;strdup %d bytes fail&quot;, __LINE__, \\ (int)strlen(pLine + 9) + 1); result = errno != 0 ? errno : ENOMEM; break; &#125; trim(pIncludeFilename); if (strncasecmp(pIncludeFilename, &quot;http://&quot;, 7) == 0) &#123; snprintf(full_filename, sizeof(full_filename),\\ &quot;%s&quot;, pIncludeFilename); &#125; else &#123; if (*pIncludeFilename == &#x27;/&#x27;) &#123; snprintf(full_filename, sizeof(full_filename), \\ &quot;%s&quot;, pIncludeFilename); &#125; else &#123; snprintf(full_filename, sizeof(full_filename), \\ &quot;%s/%s&quot;, pContext-&gt;config_path, \\ pIncludeFilename); &#125; if (!fileExists(full_filename)) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;include file \\&quot;%s\\&quot; not exists, &quot; \\ &quot;line: \\&quot;%s\\&quot;&quot;, __LINE__, \\ pIncludeFilename, pLine); free(pIncludeFilename); result = ENOENT; break; &#125; &#125; pContext-&gt;current_section = &amp;pContext-&gt;global; result = iniDoLoadFromFile(full_filename, pContext); // call again if (result != 0) &#123; free(pIncludeFilename); break; &#125; pContext-&gt;current_section = &amp;pContext-&gt;global; // 将当前处理的section指向pContext-&gt;global pSection = pContext-&gt;current_section; pItem = pSection-&gt;items + pSection-&gt;count; //must re-asign free(pIncludeFilename); continue; &#125; else if ((*pLine == &#x27;#&#x27; &amp;&amp; \\ strncasecmp(pLine+1, &quot;@function&quot;, 9) == 0 &amp;&amp; \\ (*(pLine+10) == &#x27; &#x27; || *(pLine+10) == &#x27;\\t&#x27;))) // 是否是@function annotation &#123; if (!pContext-&gt;ignore_annotation) &#123; nNameLen = strlen(pLine + 11); if (nNameLen &gt; FAST_INI_ITEM_NAME_LEN) &#123; nNameLen = FAST_INI_ITEM_NAME_LEN; &#125; memcpy(pFuncName, pLine + 11, nNameLen); pFuncName[nNameLen] = &#x27;\\0&#x27;; trim(pFuncName); if ((int)strlen(pFuncName) &gt; 0) &#123; isAnnotation = 1; pAnnoItemLine = pLastEnd + 1; &#125; else &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;the function name of annotation line is empty&quot;, \\ __LINE__); &#125; &#125; continue; &#125; trim(pLine); if (*pLine == &#x27;#&#x27; || *pLine == &#x27;\\0&#x27;) &#123; continue; &#125; nLineLen = strlen(pLine); if (*pLine == &#x27;[&#x27; &amp;&amp; *(pLine + (nLineLen - 1)) == &#x27;]&#x27;) //section &#123; char *section_name; int section_len; *(pLine + (nLineLen - 1)) = &#x27;\\0&#x27;; section_name = pLine + 1; //skip [ trim(section_name); if (*section_name == &#x27;\\0&#x27;) //global section &#123; pContext-&gt;current_section = &amp;pContext-&gt;global; pSection = pContext-&gt;current_section; pItem = pSection-&gt;items + pSection-&gt;count; continue; &#125; section_len = strlen(section_name); pSection = (IniSection *)hash_find(&amp;pContext-&gt;sections,\\ section_name, section_len); if (pSection == NULL) // not find &#123; pSection = (IniSection *)malloc(sizeof(IniSection)); if (pSection == NULL) &#123; result = errno != 0 ? errno : ENOMEM; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot;\\ &quot;malloc %d bytes fail, &quot; \\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, \\ (int)sizeof(IniSection), \\ result, STRERROR(result)); break; &#125; memset(pSection, 0, sizeof(IniSection)); result = hash_insert(&amp;pContext-&gt;sections, \\ section_name, section_len, pSection); if (result &lt; 0) &#123; result *= -1; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot;\\ &quot;insert into hash table fail, &quot;\\ &quot;errno: %d, error info: %s&quot;, \\ __LINE__, result, \\ STRERROR(result)); break; &#125; else &#123; result = 0; &#125; &#125; pContext-&gt;current_section = pSection; pItem = pSection-&gt;items + pSection-&gt;count; continue; &#125; pEqualChar = strchr(pLine, &#x27;=&#x27;); if (pEqualChar == NULL) &#123; continue; &#125; nNameLen = pEqualChar - pLine; nValueLen = strlen(pLine) - (nNameLen + 1); // means we can not have &#x27; &#x27; or &#x27;\\t&#x27; before &#x27;=&#x27; and after &#x27;=&#x27; if (nNameLen &gt; FAST_INI_ITEM_NAME_LEN) &#123; nNameLen = FAST_INI_ITEM_NAME_LEN; &#125; if (nValueLen &gt; FAST_INI_ITEM_VALUE_LEN) &#123; nValueLen = FAST_INI_ITEM_VALUE_LEN; &#125; if (pSection-&gt;count &gt;= pSection-&gt;alloc_count) &#123; result = remallocSection(pSection, &amp;pItem); if (result) &#123; break; &#125; &#125; memcpy(pItem-&gt;name, pLine, nNameLen); memcpy(pItem-&gt;value, pEqualChar + 1, nValueLen); // means we can not have &#x27; &#x27; or &#x27;\\t&#x27; before &#x27;=&#x27; and after &#x27;=&#x27; trim(pItem-&gt;name); // it allow has space before or after &#x27;=&#x27; trim(pItem-&gt;value); if (isAnnotation) // access the global variable: g_annotataionMap and make some process &#123; isAnnotation = 0; if (g_annotataionMap == NULL) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;not set annotataionMap and (%s) will use &quot; \\ &quot;the item value (%s)&quot;, __LINE__, pItem-&gt;name, pItem-&gt;value); pSection-&gt;count++; pItem++; continue; &#125; nItemCnt = -1; pAnnoMap = g_annotataionMap; while (pAnnoMap-&gt;func_name) &#123; if (strcmp(pFuncName, pAnnoMap-&gt;func_name) == 0) &#123; if (pAnnoMap-&gt;func_init) &#123; pAnnoMap-&gt;func_init(); &#125; if (pAnnoMap-&gt;func_get) &#123; nItemCnt = pAnnoMap-&gt;func_get(pItem-&gt;value, pItemValues, 100); &#125; break; &#125; pAnnoMap++; &#125; if (nItemCnt == -1) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;not found corresponding annotation function: %s, &quot; \\ &quot;\\&quot;%s\\&quot; will use the item value \\&quot;%s\\&quot;&quot;, __LINE__, pFuncName, pItem-&gt;name, pItem-&gt;value); pSection-&gt;count++; pItem++; continue; &#125; else if (nItemCnt == 0) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;annotation function %s execute fail, &quot; \\ &quot;\\&quot;%s\\&quot; will use the item value \\&quot;%s\\&quot;&quot;, __LINE__, pFuncName, pItem-&gt;name, pItem-&gt;value); pSection-&gt;count++; pItem++; continue; &#125; pItemName = pItem-&gt;name; nNameLen = strlen(pItemName); for (i = 0; i &lt; nItemCnt; i++) &#123; nValueLen = strlen(pItemValues[i]); if (nValueLen &gt; FAST_INI_ITEM_VALUE_LEN) &#123; nValueLen = FAST_INI_ITEM_VALUE_LEN; &#125; memcpy(pItem-&gt;name, pItemName, nNameLen); memcpy(pItem-&gt;value, pItemValues[i], nValueLen); pItem-&gt;value[nValueLen] = &#x27;\\0&#x27;; pSection-&gt;count++; pItem++; if (pSection-&gt;count &gt;= pSection-&gt;alloc_count) &#123; result = remallocSection(pSection, &amp;pItem); if (result) &#123; break; &#125; &#125; &#125; continue; &#125; pSection-&gt;count++; pItem++; &#125; // result is 0 means has not error occured if (result == 0 &amp;&amp; isAnnotation) &#123; logWarning(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;the @function annotation line &quot; \\ &quot;must follow by key=value line!&quot;, __LINE__); &#125; return result; &#125;// get the rid of white space from the left and right of pStrchar *trim(char *pStr)&#123; trim_right(pStr); trim_left(pStr); return pStr;&#125;//get rid of the white space from the left of pStrchar *trim_left(char *pStr)&#123; char *p; char *pEnd; int nDestLen; pEnd = pStr + strlen(pStr); for (p=pStr; p&lt;pEnd; p++) &#123; if (!(&#x27; &#x27; == *p|| &#x27;\\n&#x27; == *p || &#x27;\\r&#x27; == *p || &#x27;\\t&#x27; == *p)) &#123; break; &#125; &#125; if ( p == pStr) &#123; return pStr; &#125; nDestLen = (pEnd - p) + 1; //including \\0 memmove(pStr, p, nDestLen); return pStr;&#125;// get rid of the white space from the right of pStrchar *trim_right(char *pStr)&#123; int len; char *p; char *pEnd; len = strlen(pStr); if (len == 0) &#123; return pStr; &#125; pEnd = pStr + len - 1; for (p = pEnd; p&gt;=pStr; p--) &#123; if (!(&#x27; &#x27; == *p || &#x27;\\n&#x27; == *p || &#x27;\\r&#x27; == *p || &#x27;\\t&#x27; == *p)) &#123; break; &#125; &#125; if (p != pEnd) &#123; *(p+1) = &#x27;\\0&#x27;; &#125; return pStr;&#125;bool fileExists(const char *filename)&#123; return access(filename, 0) == 0;&#125;// allocate enough space for sectionstatic int remallocSection(IniSection *pSection, IniItem **pItem)&#123; int bytes, result; IniItem *pNew; if (pSection-&gt;alloc_count == 0) &#123; pSection-&gt;alloc_count = _INIT_ALLOC_ITEM_COUNT; &#125; else &#123; pSection-&gt;alloc_count *= 2; &#125; bytes = sizeof(IniItem) * pSection-&gt;alloc_count; pNew = (IniItem *)malloc(bytes); if (pNew == NULL) &#123; logError(&quot;file: &quot;__FILE__&quot;, line: %d, &quot; \\ &quot;malloc %d bytes fail&quot;, __LINE__, bytes); result = errno != 0 ? errno : ENOMEM; return result; &#125; if (pSection-&gt;count &gt; 0) &#123; memcpy(pNew, pSection-&gt;items, sizeof(IniItem) * pSection-&gt;count); free(pSection-&gt;items); &#125; pSection-&gt;items = pNew; *pItem = pSection-&gt;items + pSection-&gt;count; memset(*pItem, 0, sizeof(IniItem) * \\ (pSection-&gt;alloc_count - pSection-&gt;count)); return 0;&#125;void *hash_find(HashArray *pHash, const void *key, const int key_len)&#123; unsigned int hash_code; HashData **ppBucket; HashData *hash_data; hash_code = pHash-&gt;hash_func(key, key_len); ppBucket = pHash-&gt;buckets + (hash_code % (*pHash-&gt;capacity)); HASH_LOCK(pHash, ppBucket - pHash-&gt;buckets) hash_data = _chain_find_entry(ppBucket, key, key_len, hash_code); HASH_UNLOCK(pHash, ppBucket - pHash-&gt;buckets) if (hash_data != NULL) &#123; return hash_data-&gt;value; &#125; else &#123; return NULL; &#125;&#125;#define HASH_LOCK(pHash, index) \\ if (pHash-&gt;lock_count &gt; 0) \\ &#123; \\ pthread_mutex_lock(pHash-&gt;locks + (index) % pHash-&gt;lock_count); \\ &#125;#define HASH_UNLOCK(pHash, index) \\ if (pHash-&gt;lock_count &gt; 0) \\ &#123; \\ pthread_mutex_unlock(pHash-&gt;locks + (index) % pHash-&gt;lock_count); \\ &#125;static HashData *_chain_find_entry(HashData **ppBucket, const void *key, \\ const int key_len, const unsigned int hash_code)&#123; HashData *hash_data; hash_data = *ppBucket; while (hash_data != NULL) &#123; if (key_len == hash_data-&gt;key_len &amp;&amp; \\ memcmp(key, hash_data-&gt;key, key_len) == 0) &#123; return hash_data; &#125; hash_data = hash_data-&gt;next; &#125; return NULL;&#125;#define hash_insert(pHash, key, key_len, value) \\ hash_insert_ex(pHash, key, key_len, value, 0, true)int hash_insert_ex(HashArray *pHash, const void *key, const int key_len, \\ void *value, const int value_len, const bool needLock)&#123; unsigned int hash_code; HashData **ppBucket; HashData *hash_data; HashData *previous; char *pBuff; int bytes; int malloc_value_size; hash_code = pHash-&gt;hash_func(key, key_len); ppBucket = pHash-&gt;buckets + (hash_code % (*pHash-&gt;capacity)); previous = NULL; if (needLock) &#123; HASH_LOCK(pHash, ppBucket - pHash-&gt;buckets) &#125; hash_data = *ppBucket; while (hash_data != NULL) &#123; if (key_len == hash_data-&gt;key_len &amp;&amp; \\ memcmp(key, hash_data-&gt;key, key_len) == 0) &#123; break; &#125; previous = hash_data; hash_data = hash_data-&gt;next; &#125; if (hash_data != NULL) //exists &#123; if (!pHash-&gt;is_malloc_value) &#123; hash_data-&gt;value_len = value_len; hash_data-&gt;value = (char *)value; if (needLock) &#123; HASH_UNLOCK(pHash, ppBucket - pHash-&gt;buckets) &#125; return 0; &#125; else &#123; if (hash_data-&gt;malloc_value_size &gt;= value_len &amp;&amp; \\ (hash_data-&gt;malloc_value_size &lt;= 128 || hash_data-&gt;malloc_value_size / 2 &lt; value_len)) &#123; hash_data-&gt;value_len = value_len; memcpy(hash_data-&gt;value, value, value_len); if (needLock) &#123; HASH_UNLOCK(pHash, ppBucket - pHash-&gt;buckets) &#125; return 0; &#125; DELETE_FROM_BUCKET(pHash, ppBucket, previous, hash_data) &#125; &#125; if (needLock) &#123; HASH_UNLOCK(pHash, ppBucket - pHash-&gt;buckets) &#125; if (!pHash-&gt;is_malloc_value) &#123; malloc_value_size = 0; &#125; else &#123; malloc_value_size = MEM_ALIGN(value_len); &#125; bytes = CALC_NODE_MALLOC_BYTES(key_len, malloc_value_size); if (pHash-&gt;max_bytes &gt; 0 &amp;&amp; pHash-&gt;bytes_used+bytes &gt; pHash-&gt;max_bytes) &#123; return -ENOSPC; &#125; pBuff = (char *)malloc(bytes); if (pBuff == NULL) &#123; return -ENOMEM; &#125; pHash-&gt;bytes_used += bytes; hash_data = (HashData *)pBuff; hash_data-&gt;malloc_value_size = malloc_value_size; hash_data-&gt;key_len = key_len; memcpy(hash_data-&gt;key, key, key_len);#ifdef HASH_STORE_HASH_CODE hash_data-&gt;hash_code = hash_code; // save the hash code for next use, it need not calculate again when next use#endif hash_data-&gt;value_len = value_len; if (!pHash-&gt;is_malloc_value) // means the buffer of value is allocated in outer space, rather than beening allocated in the end of the key buffer &#123; hash_data-&gt;value = (char *)value; &#125; else &#123; hash_data-&gt;value = hash_data-&gt;key + hash_data-&gt;key_len; memcpy(hash_data-&gt;value, value, value_len); &#125; if (needLock) &#123; HASH_LOCK(pHash, ppBucket - pHash-&gt;buckets) ADD_TO_BUCKET(pHash, ppBucket, hash_data) HASH_UNLOCK(pHash, ppBucket - pHash-&gt;buckets) &#125; else &#123; ADD_TO_BUCKET(pHash, ppBucket, hash_data) &#125; if (pHash-&gt;load_factor &gt;= 0.10 &amp;&amp; (double)pHash-&gt;item_count / (double)*pHash-&gt;capacity &gt;= pHash-&gt;load_factor) &#123; _rehash(pHash); // rehash &#125; return 1;&#125;// delete a hash_data from pHash#define DELETE_FROM_BUCKET(pHash, ppBucket, previous, hash_data) \\ if (previous == NULL) \\ &#123; \\ *ppBucket = hash_data-&gt;next; \\ &#125; \\ else \\ &#123; \\ previous-&gt;next = hash_data-&gt;next; \\ &#125; \\ pHash-&gt;item_count--; \\ pHash-&gt;bytes_used -= CALC_NODE_MALLOC_BYTES(hash_data-&gt;key_len, \\ hash_data-&gt;malloc_value_size); \\ free(hash_data);#define MEM_ALIGN(x) (((x) + 7) &amp; (~7))#define CALC_NODE_MALLOC_BYTES(key_len, value_size) \\ sizeof(HashData) + key_len + value_size#define ADD_TO_BUCKET(pHash, ppBucket, hash_data) \\ hash_data-&gt;next = *ppBucket; \\ *ppBucket = hash_data; \\ pHash-&gt;item_count++;static int _rehash(HashArray *pHash)&#123; int result; unsigned int *pOldCapacity; pOldCapacity = pHash-&gt;capacity; if (pHash-&gt;is_malloc_capacity) &#123; unsigned int *pprime; unsigned int *prime_end; pHash-&gt;capacity = NULL; prime_end = prime_array + PRIME_ARRAY_SIZE; for (pprime = prime_array; pprime!=prime_end; pprime++) &#123; if (*pprime &gt; *pOldCapacity) &#123; pHash-&gt;capacity = pprime; break; &#125; &#125; &#125; else &#123; pHash-&gt;capacity++; &#125; if ((result=_rehash1(pHash, *pOldCapacity, pHash-&gt;capacity)) != 0) &#123; pHash-&gt;capacity = pOldCapacity; //rollback &#125; else &#123; if (pHash-&gt;is_malloc_capacity) &#123; free(pOldCapacity); pHash-&gt;is_malloc_capacity = false; &#125; &#125; /*printf(&quot;rehash, old_capacity=%d, new_capacity=%d\\n&quot;, \\ old_capacity, *pHash-&gt;capacity); */ return result;&#125;// rehash by new size: *new_capacitystatic int _rehash1(HashArray *pHash, const int old_capacity, \\ unsigned int *new_capacity)&#123; HashData **old_buckets; HashData **ppBucket; HashData **bucket_end; HashData *hash_data; HashData *pNext; int result; old_buckets = pHash-&gt;buckets; pHash-&gt;capacity = new_capacity; if ((result=_hash_alloc_buckets(pHash, old_capacity)) != 0) &#123; pHash-&gt;buckets = old_buckets; return result; &#125; //printf(&quot;old: %d, new: %d\\n&quot;, old_capacity, *pHash-&gt;capacity); pHash-&gt;item_count = 0; bucket_end = old_buckets + old_capacity; for (ppBucket=old_buckets; ppBucket&lt;bucket_end; ppBucket++) &#123; if (*ppBucket == NULL) &#123; continue; &#125; hash_data = *ppBucket; while (hash_data != NULL) &#123; pNext = hash_data-&gt;next; ADD_TO_BUCKET(pHash, (pHash-&gt;buckets + \\ (HASH_CODE(pHash, hash_data) % \\ (*pHash-&gt;capacity))), hash_data) hash_data = pNext; &#125; &#125; free(old_buckets); return 0;&#125;char *iniGetStrValue(const char *szSectionName, const char *szItemName, \\ IniContext *pContext)&#123; IniItem targetItem; IniSection *pSection; IniItem *pItem; INI_FIND_ITEM(szSectionName, szItemName, pContext, pSection, \\ targetItem, pItem, NULL) if (pItem == NULL) &#123; return NULL; &#125; else &#123; return pItem-&gt;value; &#125;&#125;#define INI_FIND_ITEM(szSectionName, szItemName, pContext, pSection, \\ targetItem, pItem, return_val) \\ if (szSectionName == NULL || *szSectionName == &#x27;\\0&#x27;) \\ &#123; \\ pSection = &amp;pContext-&gt;global; \\ &#125; \\ else \\ &#123; \\ pSection = (IniSection *)hash_find(&amp;pContext-&gt;sections, \\ szSectionName, strlen(szSectionName)); \\ if (pSection == NULL) \\ &#123; \\ return return_val; \\ &#125; \\ &#125; \\ \\ if (pSection-&gt;count &lt;= 0) \\ &#123; \\ return return_val; \\ &#125; \\ \\ snprintf(targetItem.name, sizeof(targetItem.name), &quot;%s&quot;, szItemName); \\ pItem = (IniItem *)bsearch(&amp;targetItem, pSection-&gt;items, \\ pSection-&gt;count, sizeof(IniItem), iniCompareByItemName); // 二分查找static void iniSortItems(IniContext *pContext)&#123; if (pContext-&gt;global.count &gt; 1) &#123; qsort(pContext-&gt;global.items, pContext-&gt;global.count, \\ sizeof(IniItem), iniCompareByItemName); &#125; hash_walk(&amp;pContext-&gt;sections, iniSortHashData, NULL);&#125;static int iniCompareByItemName(const void *p1, const void *p2)&#123; return strcmp(((IniItem *)p1)-&gt;name, ((IniItem *)p2)-&gt;name);&#125;int hash_walk(HashArray *pHash, HashWalkFunc walkFunc, void *args)&#123; HashData **ppBucket; HashData **bucket_end; HashData *hash_data; int index; int result; index = 0; bucket_end = pHash-&gt;buckets + (*pHash-&gt;capacity); for (ppBucket=pHash-&gt;buckets; ppBucket&lt;bucket_end; ppBucket++) &#123; hash_data = *ppBucket; while (hash_data != NULL) &#123; result = walkFunc(index, hash_data, args); if (result != 0) &#123; return result; &#125; index++; hash_data = hash_data-&gt;next; &#125; &#125; return 0;&#125;void iniFreeContext(IniContext *pContext)&#123; if (pContext == NULL) &#123; return; &#125; if (pContext-&gt;global.items != NULL) &#123; free(pContext-&gt;global.items); memset(&amp;pContext-&gt;global, 0, sizeof(IniSection)); &#125; hash_walk(&amp;pContext-&gt;sections, iniFreeHashData, NULL); hash_destroy(&amp;pContext-&gt;sections); iniFreeDynamicContent(pContext);&#125;void hash_destroy(HashArray *pHash)&#123; HashData **ppBucket; HashData **bucket_end; HashData *pNode; HashData *pDelete; if (pHash == NULL || pHash-&gt;buckets == NULL) &#123; return; &#125; bucket_end = pHash-&gt;buckets + (*pHash-&gt;capacity); for (ppBucket=pHash-&gt;buckets; ppBucket&lt;bucket_end; ppBucket++) &#123; pNode = *ppBucket; while (pNode != NULL) &#123; pDelete = pNode; pNode = pNode-&gt;next; free(pDelete); &#125; &#125; free(pHash-&gt;buckets); pHash-&gt;buckets = NULL; if (pHash-&gt;is_malloc_capacity) &#123; free(pHash-&gt;capacity); pHash-&gt;capacity = NULL; pHash-&gt;is_malloc_capacity = false; &#125; pHash-&gt;item_count = 0; pHash-&gt;bytes_used = 0;&#125;static void iniFreeDynamicContent(IniContext *pContext)&#123; CDCPair *pCDCPair; DynamicContents *pDynamicContents; int i; if (g_dynamic_content_count == 0) &#123; return; &#125; if (g_dynamic_contents[g_dynamic_content_index].context == pContext) &#123; pCDCPair = g_dynamic_contents + g_dynamic_content_index; &#125; else &#123; pCDCPair = NULL; for (i=0; i&lt;_MAX_DYNAMIC_CONTENTS; i++) &#123; if (g_dynamic_contents[i].context == pContext) &#123; pCDCPair = g_dynamic_contents + i; break; &#125; &#125; if (pCDCPair == NULL) &#123; return; &#125; &#125; pCDCPair-&gt;used = false; pCDCPair-&gt;context = NULL; pDynamicContents = &amp;pCDCPair-&gt;dynamicContents; if (pDynamicContents-&gt;contents != NULL) &#123; for (i=0; i&lt;pDynamicContents-&gt;count; i++) &#123; if (pDynamicContents-&gt;contents[i] != NULL) &#123; free(pDynamicContents-&gt;contents[i]); &#125; &#125; free(pDynamicContents-&gt;contents); pDynamicContents-&gt;contents = NULL; &#125; pDynamicContents-&gt;alloc_count = 0; pDynamicContents-&gt;count = 0; g_dynamic_content_count--;&#125;","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"}]},{"title":"hexo之使用Travis自动部署hexo","slug":null,"date":"2016-10-29T07:29:31.000Z","updated":null,"comments":null,"path":"tools/2016-10-29/hexo之使用Travis自动部署hexo.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"参考文章1参考文章2使用hexo+github搭建完自己的博客之后，每次新增文章，都需要hexo g-&gt;hexo d进行发布，此外为了进行备份，也需要将博客目录push到source repo上去(这里就有两个repo：source repo和content repo,我们的github博客网站的真实数据就保存在content repo,而source repo为我们本地博客目录的备份repo),有没有一种解决方案实现push到source repo上去时，自动进行发布呢？答案肯定是yes，这就是hexo的持续集成,实现工具有很多，如：appveyor(针对windows，linux下尝试未成功)，travis等，这里我们使用travis。 目的 一次性实现备份和发布； 方便在不同的电脑上进行博客发布。 实现步骤新建Personal Access Tokens到自己的github上，新建Personal access tokens，选择repo和admin:repo_hook权限，新建文件保存到本地。 配置travis ci实现github账号登陆travis官网，并active自己的source reop，且将“Build only if .travis.yml is present”选项打开。 本地安装travis执行命令： 123sudo apt-get install ruby2.0sudo apt-get install rubygemssudo gem install travis 安装时可能出现相关文件版本号大于某个版本的错误，此时执行:sudo gem install xxx。 配置travisgit clone下自己的source repo, 到根目录执行: 12345678touch .travis.yml# 这里的 REPO_TOKEN 是变量名,在后面的配置文件中会用到# TOKEN 是上面github生成的Tokentravis encrypt &#x27;REPO_TOKEN=&lt;TOKEN&gt;&#x27; --add# 执行完后，.travis.yml文件中包含如下内容：env: global: secure: Kl6AZLqFTGwm3CAktb3Idl2qNstdkC/SdYpyXJcehNnbubfur5Rqpjsy2UplG37+mzZW33UJszBwOrlu/YgNgMKfGPGGs55Wv... 加入其他相关脚本到.travis.yml文件中去，完整的.travis.yml内容如下： 1234567891011121314151617181920212223242526272829303132333435language: node_jsnode_js:- &quot;4&quot; # nodejs的版本branches: only: - master # 设置自动化部署的源码分支env: global: secure: Kl6AZLqFTGwm3CAktb3Idl2qNstdkC/SdYpyXJcehNnbubfur5Rqpjsy2UplG37+mzZW33UJszBwOrlu/YgNgMKfGPGGs55WvrayaJrjvnXLetdVW4X7WraviCcWFAcHLTtkhF9gmz9DXWYr8FM+rp16AFKU2uWEx1S8/LhxGsRuMwO1SHJqZbWaMUnV88nvg19uN2mfzXzsukmv3cR+rSPa/ybauZj9qBaDb+y+1bsOGECC3TdiyikInRnX3IZDxf+YxSZGqMSl4wXzHWamVZB03LU3AhfUhfZEOhfFpcJG+nnLuS8h092BiEtpGixTewdtpdRPoil3CASGEQ8JvuZ90T/NaiD6m0HTxLZ4zXrWlPLbtCnPXwWli672XcNEiNgZB8COB0IkWv2FQoPl1H7B6UqdwxSxte3aN5YqVfkY7CiJtu+GAFH8u2JSO0OiK+V773vqz+xdt0fB1tXItL2AQtoSrhrr5QchJN5oZhFQpzr/g97O8gBgAQ2p0GLxY3BiFIccGX4hN1Lls/+0WKHPQ3dfFs49jvmelg6fhrYcYQhH/iVJtkIf3TjPq0CvQhiqzMjZoafle9U8RmuY/q/UaoswmkGHQ97qER5QpBWRpDH6JLQOJ63+aiWM53STyrJdraU+vJGGtc5KfTnkRd1Y82c=before_install:- export TZ=&#x27;Asia/Shanghai&#x27; - npm install -g hexo- npm install -g hexo-cli before_script:# ------------------------------------------------# 设置github账户信息 注意修改成自己的信息# ------------------------------------------------- git config --global user.name &quot;damotiansheng&quot;- git config --global user.email 974361900@qq.com# ------------------------------------------------# github仓库操作 注意将仓库修改成自己的# ------------------------------------------------- sed -i&#x27;&#x27; &quot;s~https://github.com/damotiansheng/damotiansheng.github.io.git~https://$&#123;REPO_TOKEN&#125;:x-oauth-basic@github.com/damotiansheng/damotiansheng.github.io.git~&quot; _config.yml# 安装依赖组件install:- npm install# 执行的命令script:- hexo clean- hexo generate# 执行的成功后执行 after_success:- hexo deploy 测试新建一篇文章，然后执行： 123git add -A .git commit -m &quot;xxx&quot;git push origin master 执行文件完后，登陆到travis官网，可以看到类似下面的内容就代表成功了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Worker informationhostname: i-8f64d817-precise-production-2-worker-org-docker.travisci.net:5de14ca3-fcc6-4e64-a6ac-bc0c8a588bd8version: v2.5.0-8-g19ea9c2 https://github.com/travis-ci/worker/tree/19ea9c20425c78100500c7cc935892b47024922cinstance: 9f2c179:travis:node_jsstartup: 481.157573mssystem_infoBuild system informationBuild language: node_jsBuild group: stableBuild dist: preciseBuild id: 182467416Job id: 182467417travis-build version: 0501eac99Build image provisioning date and timeThu Feb 5 15:09:33 UTC 2015Operating System DetailsDistributor ID: UbuntuDescription: Ubuntu 12.04.5 LTSRelease: 12.04Codename: preciseLinux Version3.13.0-29-genericCookbooks Versiona68419e https://github.com/travis-ci/travis-cookbooks/tree/a68419eGCC versiongcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3Copyright (C) 2011 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.Apache Maven 3.2.5 (12a6b3acb947671f09b81f49094c53f426d8cea1; 2014-12-14T17:29:23+00:00)Maven home: /usr/local/mavenJava version: 1.7.0_76, vendor: Oracle CorporationJava home: /usr/lib/jvm/java-7-oracle/jreDefault locale: en_US, platform encoding: ANSI_X3.4-1968OS name: &quot;linux&quot;, version: &quot;3.13.0-29-generic&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;fix.CVE-2015-7547$ export DEBIAN_FRONTEND=noninteractivenvm install 4...hexo cleanINFO Deleted database.INFO Deleted public folder.hexo deploy...Done. Your build exited with 0. 此时到自己的github source repo和content repo均可看到最新的提交，访问自己github博客网站也可看到最新的文章了。","raw":null,"content":null,"categories":null,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damotiansheng.github.io/tags/hexo/"},{"name":"travis","slug":"travis","permalink":"http://damotiansheng.github.io/tags/travis/"}]},{"title":"fastdfs文件系统搭建","slug":null,"date":"2016-10-21T08:54:20.000Z","updated":null,"comments":null,"path":"uncategorized/2016-10-21/fastdfs文件系统搭建.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"ubantu14.04 x64下搭建FastDFS分布式存储环境（使用Nginx模块） 1. 软件准备1.1 从happyfish100下载最新的fastdfs（当前为v5.08）、libfastcommon、fastdfs-nginx-module；1.2 从nginx官网下载nginx,我下载的版本为nginx-1.10.2.tar.gz2. 安装libfastcommon2.1 安装12#./makesh#./make.sh install 2.2 配置但是FastDFS主程序设置的lib目录是&#x2F;usr&#x2F;local&#x2F;lib所以需要创建软链接. 1234ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.soln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.soln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.soln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 3. 安装fastdfs主程序3.1 安装进入fastdfs主目录，依次执行： 12./make.sh ./make.sh install 执行完毕后，可执行文件在&#x2F;usr&#x2F;bin&#x2F;下以fdfs开头，ll &#x2F;usr&#x2F;bin&#x2F;fdfs，会看到一些可执行程序，如fdfs_upload_file等；在&#x2F;etc&#x2F;fdfs&#x2F;目录下也有一些配置文件，如：storage.conf.sample等；执行： cp fastdfs&#x2F;conf&#x2F; &#x2F;etc&#x2F;fdfs，即将conf目录下的所有文件复制到&#x2F;etc&#x2F;fdfs目录下 3.2 配置在fastdfs同级目录，新建目录storage_base_path，client_base_path，mod_fastdfs_base_path，store_path0，tracker_base_path修改&#x2F;etc&#x2F;fdfs&#x2F;tracker.conf(若没有，则cp &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf.sample &#x2F;etc&#x2F;fdfs&#x2F;tracker.conf)将base_path的值设置为tracker_base_path目录，如： 123456789101112131415vim /etc/fdfs/tracker.confbase_path=/home/hyp/Desktop/opensource/tracker_base_pathhttp.server_port=8080vim /etc/fdfs/storage.confgroup_name=group1base_path=/home/hyp/Desktop/opensource/storage_base_pathstore_path0=/home/hyp/Desktop/opensource/storage_base_pathtracker_server=172.16.55.156:22122http.server_port=8080vim /etc/fdfs/client.confbase_path=/home/hyp/Desktop/opensource/client_base_pathtracker_server=172.16.55.156:22122 3.3 测试12345678910111213141516171819which fdfs_storaged /usr/bin/fdfs_storagedfdfs_trackerd /etc/fdfs/tracker.conf restartnetstat -antp | grep trackerdfdfs_storaged /etc/fdfs/storage.conf restartnetstat -antp | grep storageps -ef|grep fdfsfdfs_upload_file client.conf ~/Desktop/fork.cgroup1/M00/00/00/rBA3nFgJeMCAUOjoAAAAxxbGNXU56061.cfdfs_upload_file client.conf ~/Desktop/kenan1.jpg group1/M00/00/00/rBA3nFgJxfKABNobAAITVP28J6s210.jpg终止命令：killall fdfs_storaged killall fdfs_trackerd 4. 安装fastdfs-nginx-module12345678修改fastdfs-nginx-module的config文件原来的内容是CORE_INCS=&quot;$CORE_INCS /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;vim /home/nginx/fastdfs-nginx-module/src/config,修改为CORE_INCS=&quot;$CORE_INCS /usr/include/fastdfs /usr/include/fastcommon&quot;注：貌似github上的fastdfs-nginx-module无需修改 5. 安装nginx并运行5.1 解压nginx-1.10.2，并执行：123./configure --prefix=/usr/local/nginx --add-module=/home/hyp/Desktop/opensource/fastdfs-nginx-module/srcmakemake install 5.2 配置12345678910111213141516171819202122232425262728293031323334cp fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/vim /usr/local/nginx/conf/nginx.conf将server字段的listen字段修改为8080并添加：location /group1/M00 &#123; root /home/hyp/Desktop/opensource/storage_base_path/data; ngx_fastdfs_module; &#125;注：/home/hyp/Desktop/opensource/storage_base_path/data该目录是指向真正存储文件的地方修改fastdfs的nginx模块的配置文件mod_fastdfs.conf:vim /etc/fdfs/mod_fastdfs.confbase_path=/home/hyp/Desktop/opensource/mod_fastdfs_base_path #保存日志目录tracker_server=172.16.55.156:22122 #tracker 服务器的 IP 地址以及端口号storage_server_port=23000 #storage 服务器的端口号group_name=group1 #当前服务器的 group 名url_have_group_name = true #文件 url 中是否有 group 名store_path_count=1 #存储路径个数，需要和 store_path 个数匹配store_path0=/home/hyp/Desktop/opensource/mod_fastdfs_base_path #存储路径http.need_find_content_type=true # 从文件 扩展 名查 找 文件 类型 （ nginx 时 为true）,好像没有该字段group_count = 1 #设置组的个数然后在末尾添加分组信息，目前只有一个分组，就只写一个[group1]group_name=group1storage_server_port=23000store_path_count=1store_path0=/home/hyp/Desktop/opensource/storage_base_path建立M00至存储目录的符号连接ln -s /home/hyp/Desktop/opensource/storage_base_path/data /home/hyp/Desktop/opensource/storage_base_path/M00 （好像删除也可以，因为上面/group1/M00的root已经指向data了） 5.3 运行123456789101112131415fdfs_trackerd /etc/fdfs/tracker.conf restartfdfs_storaged /etc/fdfs/storage.conf restartfdfs_upload_file /etc/fdfs/client.conf ~/Desktop/kenan.jpg group1/M00/00/00/rBA3nFgJuvmAHHJ0AAENmFEdiOY703.jpg到/usr/local/nginx/sbin目录，执行: ./nginx./nginxngx_http_fastdfs_set pid=22882lsof -i:8080COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEnginx 22883 root 6u IPv4 860115 0t0 TCP *:http-alt (LISTEN)nginx 22884 nobody 6u IPv4 860115 0t0 TCP *:http-alt (LISTEN)输入http://localhost:8080/即可显示首页输入http://localhost:8080/group1/M00/00/00/rBA3nFgJuvmAHHJ0AAENmFEdiOY703.jpg即可显示kenan.jpg图片了 6. 遇到的问题6.1 官网下载最新版本后，我下载的为nginx-1.10.2.tar.gz，编译运行1234ps -aux|grep nginx出现：root 7421 0.0 0.0 28588 564 ? Ss 09:42 0:00 nginx: master process ./nginxnobody 7422 0.0 0.0 29012 2552 ? S 09:42 0:00 nginx: worker process 但是在我ubantu12.04 x64的笔记本上只出现了一个进程，怪了，在ubantu12.04上，添加模块–add-module&#x3D;&#x2F;home&#x2F;hyp&#x2F;Desktop&#x2F;opensource&#x2F;fastdfs-nginx-module&#x2F;src后，也只有一个进程了，且此时浏览器访问localhost时，总是无法显示，浏览器总在转圈，可能原因是配置文件中的http.server_port端口没有配置好，端口需要配置与nginx中监听的端口一致，或者是mod_fastdfs.conf文件没有配置好，如末尾没有添加分组信息，此问题困扰了两天； 6.2 有时执行: fdfs_storaged storage.conf123456789101112[2016-10-21 10:30:12] ERROR - file: shared_func.c, line: 968, /storage.conf is not a regular fileroot@hyp-HP-Pro-3340-MT:/etc/fdfs# [2016-10-21 10:30:12] ERROR - file: storage_func.c, line: 1076, load conf file &quot;storage.conf&quot; fail, ret code: 22[2016-10-21 10:30:12] CRIT - exit abnormally!^C[2016-10-21 10:03:10] ERROR - file: shared_func.c, line: 968, /./storage.conf is not a regular file[2016-10-21 10:03:10] ERROR - file: storage_func.c, line: 1076, load conf file &quot;./storage.conf&quot; fail, ret code: 22[2016-10-21 10:03:10] CRIT - exit abnormally!^C使用完整路径即可： fdfs_storaged /etc/fdfs/storage.conf 7. 参考来源：http://www.tuicool.com/articles/q6ZvUn http://www.tuicool.com/articles/q6ZvUn","raw":null,"content":null,"categories":null,"tags":[{"name":"fastdfs","slug":"fastdfs","permalink":"http://damotiansheng.github.io/tags/fastdfs/"},{"name":"分布式文件系统","slug":"分布式文件系统","permalink":"http://damotiansheng.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"nginx","slug":"nginx","permalink":"http://damotiansheng.github.io/tags/nginx/"}]},{"title":"Hello World","slug":null,"date":"2016-10-21T07:29:31.000Z","updated":null,"comments":null,"path":"tools/2016-10-21/hello-world.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":null,"content":null,"categories":null,"tags":[{"name":"hexo","slug":"hexo","permalink":"http://damotiansheng.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://damotiansheng.github.io/tags/github/"}]},{"title":"搭建github博客","slug":null,"date":"2016-10-14T02:42:33.000Z","updated":null,"comments":null,"path":"uncategorized/2016-10-14/搭建github博客.html","link":null,"permalink":null,"excerpt":null,"keywords":null,"text":"目的: 利用hexo将个人博客搭建到github上参考的相关文章 1、下载node-v4.6.0-linux-x64.tar.xz该压缩包中包含了编译好的hexo,npm,node可执行文件，可以直接使用 2、将hexo可执行文件路径添加到PATH中3、初始化新建你要存放博客内容的目录，cd到该目录，执行： 1$hexo init 4、生成静态页面1$hexo generate 5、本地启动1$hexo server ６、浏览器访问执行完hexo server之后，浏览器输入http://localhost:4000/查看页面效果 ７、部署博客到github上去7.1 新建github仓库，命名规则：你的github账号.github.io7.2 修改_config.yml到该文件末尾，添加内容如下：deploy: type: git repo: 刚刚创建的github仓库地址.git branch: master注意：type,repo,branch后面有一个空格 7.3 部署到github上123$hexo clean$hexo g$hexo d 7.4 浏览器访问输入https:&#x2F;&#x2F;你的github账号.github.io即可访问你的博客了。 8、hexo命令8.1 简写 hexo n &#x3D;&#x3D; hexo new hexo g &#x3D;&#x3D; hexo generate hexo s &#x3D;&#x3D; hexo server hexo d &#x3D;&#x3D; hexo deploy 8.2 新建文章 执行hexo new “标题”命令后会在_posts目录会生成文件标题.md，编辑该文件就是编辑该文章 8.3 hexo部署12$hexo g$hexo d 9、添加评论和头像9.1 添加评论 到多说申请站点 修改theme-yilia下的_config.yml文件，修改为：duoshuo: 站点名称 重新生成并部署即可 如果不行，请参考Hexo使用多说教程 9.2 添加头像 在主目录下的source文件夹下(与_posts同目录)新建photos目录，并将xxx.png放到该目录 修改theme-yilia下的_config.yml文件，修改为：avatar: &#x2F;photos&#x2F;xxx.png 重新生成并部署即可 10、注意 有时hexo new xxx文章后，发布后有乱码，此时删除该文章，然后直接vim新建，然后到博客主目录下执行hexo g -&gt; hexo d，有乱码可能就是由于没有在主目录下执行命令，而在_posts目录下执行命令进行发布了。 11、参考文章hexo使用攻略","raw":null,"content":null,"categories":null,"tags":[{"name":"搭建github博客","slug":"搭建github博客","permalink":"http://damotiansheng.github.io/tags/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/"}]}]